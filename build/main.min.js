import*as t from"https://resources.realitymedia.digital/test-vue-app/dist/hubs.min.js";AFRAME.registerSystem("fader-plus",{schema:{direction:{type:"string",default:"none"},duration:{type:"number",default:200},color:{type:"color",default:"white"}},init(){const t=new THREE.Mesh(new THREE.BoxGeometry,new THREE.MeshBasicMaterial({color:this.data.color,side:THREE.BackSide,opacity:0,transparent:!0,fog:!1}));t.scale.x=t.scale.y=1,t.scale.z=.15,t.matrixNeedsUpdate=!0,t.renderOrder=1,this.el.camera.add(t),this.mesh=t},fadeOut(){return this.beginTransition("out")},fadeIn(){return this.beginTransition("in")},async beginTransition(t){if(this._resolveFinish)throw new Error("Cannot fade while a fade is happening.");return this.el.setAttribute("fader-plus",{direction:t}),new Promise((e=>{this.mesh.material.opacity===("in"==t?0:1)?e():this._resolveFinish=e}))},tick(t,e){const i=this.mesh.material;this.mesh.visible="out"===this.data.direction||0!==i.opacity,this.mesh.visible&&("in"===this.data.direction?i.opacity=Math.max(0,i.opacity-1/this.data.duration*Math.min(e,50)):"out"===this.data.direction&&(i.opacity=Math.min(1,i.opacity+1/this.data.duration*Math.min(e,50))),0!==i.opacity&&1!==i.opacity||("none"!==this.data.direction&&this._resolveFinish&&(this._resolveFinish(),this._resolveFinish=null),this.el.setAttribute("fader-plus",{direction:"none"})))}});const e=new THREE.Vector3,i=new THREE.Vector3;AFRAME.registerComponent("proximity-events",{schema:{radius:{type:"number",default:1}},init(){this.inZone=!1,this.camera=this.el.sceneEl.camera},tick(){this.camera.getWorldPosition(e),this.el.object3D.getWorldPosition(i);const t=this.inZone;this.inZone=e.distanceTo(i)<this.data.radius,this.inZone&&!t&&this.el.emit("proximityenter"),!this.inZone&&t&&this.el.emit("proximityleave")}});const a=new THREE.Vector3,r=new THREE.Vector3,s=new THREE.Vector3,n=new THREE.Quaternion,o=new THREE.Matrix4;AFRAME.registerSystem("portal",{dependencies:["fader-plus"],init:function(){this.teleporting=!1,this.characterController=this.el.systems["hubs-systems"].characterController,this.fader=this.el.systems["fader-plus"],this.roomData=null,this.waitForFetch=this.waitForFetch.bind(this),window.APP.store.state.credentials&&window.APP.store.state.credentials.token&&!window.APP.userData&&this.fetchRoomData()},fetchRoomData:async function(){var t={token:window.APP.store.state.credentials.token,room_id:window.APP.hubChannel.hubId};const e={};e.headers=new Headers,e.headers.set("Authorization",`Bearer ${t}`),e.headers.set("Content-Type","application/json"),await fetch("https://realitymedia.digital/userData",e).then((t=>t.json())).then((t=>{console.log("Success:",t),this.roomData=t})),this.roomData.textures=[]},getRoomURL:async function(t){return this.waitForFetch(),this.roomData.rooms.length>t?"https://xr.realitymedia.digital/"+this.roomData.rooms[t]:null},getCubeMap:async function(t){return this.waitForFetch(),this.roomData.cubemaps.length>t?this.roomData.cubemaps[t]:null},waitForFetch:function(){this.roomData||setTimeout(this.waitForFetch,100)},teleportTo:async function(t){this.teleporting=!0,await this.fader.fadeOut(),t.getWorldQuaternion(n),t.getWorldDirection(s),t.getWorldPosition(a),a.add(s.multiplyScalar(1.5)),o.makeRotationFromQuaternion(n),o.setPosition(a),this.characterController.travelByWaypoint(o,!0,!1),await this.fader.fadeIn(),this.teleporting=!1}}),AFRAME.registerComponent("portal",{schema:{color:{type:"color",default:null}},init:async function(){this.system=APP.scene.systems.portal,this.parseNodeName(),this.material=new THREE.ShaderMaterial({transparent:!0,side:THREE.DoubleSide,uniforms:{cubeMap:{value:new THREE.Texture},time:{value:0},radius:{value:0},ringColor:{value:this.color}},vertexShader:"\nvarying vec2 vUv;\nvarying vec3 vRay;\nvarying vec3 vNormal;\n\nvoid main() {\n  vUv = uv;\n  // vNormal = normalMatrix * normal;\n  vec3 cameraLocal = (inverse(modelMatrix) * vec4(cameraPosition, 1.0)).xyz;\n  vRay = position - cameraLocal;\n  vNormal = normalize(-1. * vRay);\n  float dist = length(cameraLocal);\n  vRay.z *= 1.3 / (1. + pow(dist, 0.5)); // Change FOV by squashing local Z direction\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\n        \n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }  \n\n        \nuniform samplerCube cubeMap;\nuniform float time;\nuniform float radius;\nuniform vec3 ringColor;\n\nvarying vec2 vUv;\nvarying vec3 vRay;\nvarying vec3 vNormal;\n\n#define RING_WIDTH 0.1\n#define RING_HARD_OUTER 0.01\n#define RING_HARD_INNER 0.08\n#define forward vec3(0.0, 0.0, 1.0)\n\nvoid main() {\n  vec2 coord = vUv * 2.0 - 1.0;\n  float noise = snoise(vec3(coord * 1., time)) * 0.5 + 0.5;\n\n  // Polar distance\n  float dist = length(coord);\n  dist += noise * 0.2;\n\n  float maskOuter = 1.0 - smoothstep(radius - RING_HARD_OUTER, radius, dist);\n  float maskInner = 1.0 - smoothstep(radius - RING_WIDTH, radius - RING_WIDTH + RING_HARD_INNER, dist);\n  float distortion = smoothstep(radius - 0.2, radius + 0.2, dist);\n  vec3 normal = normalize(vNormal);\n  float directView = smoothstep(0., 0.8, dot(normal, forward));\n  vec3 tangentOutward = vec3(coord, 0.0);\n  vec3 ray = mix(vRay, tangentOutward, distortion);\n  vec4 texel = textureCube(cubeMap, ray);\n  vec3 centerLayer = texel.rgb * maskInner;\n  vec3 ringLayer = ringColor * (1. - maskInner);\n  vec3 composite = centerLayer + ringLayer;\n\n  gl_FragColor = vec4(composite, (maskOuter - maskInner) + maskInner * directView);\n}\n\n      "});this.el.getOrCreateObject3D("mesh").material=this.material,this.other=await this.getOther(),1==this.portalType?this.system.getCubeMap(this.portalTarget).then((t=>{new Promise(((e,i)=>(new THREE.CubeTextureLoader).load(t,e,void 0,i))).then((t=>{t.format=THREE.RGBFormat,this.material.uniforms.cubeMap.value=t})).catch((t=>console.error(t)))})):2==this.portalType&&(this.cubeCamera=new THREE.CubeCamera(1,1e5,1024),this.cubeCamera.rotateY(Math.PI),this.el.object3D.add(this.cubeCamera),this.other.components.portal.material.uniforms.cubeMap.value=this.cubeCamera.renderTarget.texture,this.el.sceneEl.addEventListener("model-loaded",(()=>{this.cubeCamera.update(this.el.sceneEl.renderer,this.el.sceneEl.object3D)}))),this.el.setAttribute("animation__portal",{property:"components.portal.material.uniforms.radius.value",dur:700,easing:"easeInOutCubic"}),this.el.addEventListener("animationbegin",(()=>this.el.object3D.visible=!0)),this.el.addEventListener("animationcomplete__portal",(()=>this.el.object3D.visible=!this.isClosed())),this.el.setAttribute("is-remote-hover-target",""),this.el.setAttribute("tags",{singleActionButton:!0}),this.el.setAttribute("class","interactable"),this.followPortal=this.followPortal.bind(this),this.el.object3D.addEventListener("interact",this.followPortal),this.el.setAttribute("proximity-events",{radius:5}),this.el.addEventListener("proximityenter",(()=>this.open())),this.el.addEventListener("proximityleave",(()=>this.close()))},followPortal:function(){1==this.portalType?(console.log("set window.location.href to "+this.other),window.location.href=this.other):2==this.portalType&&this.system.teleportTo(this.other.object3D)},tick:function(t){if(this.material.uniforms.time.value=t/1e3,this.other&&!this.system.teleporting){this.el.object3D.getWorldPosition(a),this.el.sceneEl.camera.getWorldPosition(r);const t=r.distanceTo(a);1==this.portalType&&t<.5||2==this.portalType&&t<1&&this.system.teleportTo(this.other.object3D)}},getOther:function(){return new Promise((t=>{0==this.portalType&&t(null),1==this.portalType&&this.system.getRoomURL(this.portalTarget).then((e=>{t(e)}));const e=Array.from(document.querySelectorAll("[portal]")).find((t=>t.components.portal.portalType==this.portalType&&t.components.portal.portalTarget===this.portalTarget&&t!==this.el));void 0!==e?(t(e),e.emit("pair",{other:this.el})):this.el.addEventListener("pair",(e=>t(e.detail.other)),{once:!0})}))},parseNodeName:function(){const t=this.el.parentEl.parentEl.className,e=t.match(/([A-Za-z]*)_([A-Za-z0-9]*)_([A-Za-z0-9]*)$/);if(!e||e.length<4)return console.warn("portal node name not formed correctly: ",t),this.portalType=0,this.portalTarget=null,void(this.color="red");"room"===e[1]?(this.portalType=1,this.portalTarget=parseInt(e[2])):"portal"===e[1]?(this.portalType=2,this.portalTarget=e[2]):(this.portalType=0,this.portalTarget=null),this.color=new THREE.Color(e[3])},setRadius(t){this.el.setAttribute("animation__portal",{from:this.material.uniforms.radius.value,to:t})},open(){this.setRadius(1)},close(){this.setRadius(0)},isClosed(){return 0===this.material.uniforms.radius.value}});const l=new THREE.Vector3,c=new THREE.Vector3;AFRAME.registerComponent("immersive-360",{schema:{url:{type:"string",default:null}},init:async function(){const t=this.data.url??this.parseSpokeName(),e=t.match(/^.*\.(.*)$/)[1];this.el.setAttribute("media-image",{projection:"360-equirectangular",alphaMode:"opaque",src:t,version:1,batch:!1,contentType:`image/${e}`,alphaCutoff:0}),this.mesh=await this.getMesh(),this.mesh.geometry.scale(100,100,100),this.mesh.material.setValues({transparent:!0,depthTest:!1}),this.near=1,this.far=1.3,this.mesh.renderOrder=APP.RENDER_ORDER.CURSOR-1},tick:function(){if(this.mesh){this.mesh.getWorldPosition(c),this.el.sceneEl.camera.getWorldPosition(l);const t=1-(c.distanceTo(l)-this.near)/(this.far-this.near);this.mesh.material.opacity=t}},parseSpokeName:function(){const t=this.el.parentEl.parentEl.className,[,e,i]=t.match(/(?:.*__)?(.*)_(.*)/);return`https://gt-ael-aq-assets.aelatgt-internal.net/files/${e}.${i}`},getMesh:async function(){return new Promise((t=>{const e=this.el.object3DMap.mesh;e&&t(e),this.el.addEventListener("image-loaded",(()=>{t(this.el.object3DMap.mesh)}),{once:!0})}))}});const h=String.raw,d={modes:{none:"NO_PARALLAX",basic:"USE_BASIC_PARALLAX",steep:"USE_STEEP_PARALLAX",occlusion:"USE_OCLUSION_PARALLAX",relief:"USE_RELIEF_PARALLAX"},uniforms:{bumpMap:{value:null},map:{value:null},parallaxScale:{value:null},parallaxMinLayers:{value:null},parallaxMaxLayers:{value:null}},vertexShader:h`
    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    void main() {
      vUv = uv;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      vViewPosition = -mvPosition.xyz;
      vNormal = normalize( normalMatrix * normal );
      
      gl_Position = projectionMatrix * mvPosition;
    }
  `,fragmentShader:h`
    uniform sampler2D bumpMap;
    uniform sampler2D map;

    uniform float parallaxScale;
    uniform float parallaxMinLayers;
    uniform float parallaxMaxLayers;
    uniform float fade; // CUSTOM

    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    #ifdef USE_BASIC_PARALLAX

    vec2 parallaxMap(in vec3 V) {
      float initialHeight = texture2D(bumpMap, vUv).r;

      // No Offset Limitting: messy, floating output at grazing angles.
      //"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

      // Offset Limiting
      vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;
      return vUv - texCoordOffset;
    }

    #else

    vec2 parallaxMap(in vec3 V) {
      // Determine number of layers from angle between V and N
      float numLayers = mix(parallaxMaxLayers, parallaxMinLayers, abs(dot(vec3(0.0, 0.0, 1.0), V)));

      float layerHeight = 1.0 / numLayers;
      float currentLayerHeight = 0.0;
      // Shift of texture coordinates for each iteration
      vec2 dtex = parallaxScale * V.xy / V.z / numLayers;

      vec2 currentTextureCoords = vUv;

      float heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;

      // while ( heightFromTexture > currentLayerHeight )
      // Infinite loops are not well supported. Do a "large" finite
      // loop, but not too large, as it slows down some compilers.
      for (int i = 0; i < 30; i += 1) {
        if (heightFromTexture <= currentLayerHeight) {
          break;
        }
        currentLayerHeight += layerHeight;
        // Shift texture coordinates along vector V
        currentTextureCoords -= dtex;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
      }

      #ifdef USE_STEEP_PARALLAX

      return currentTextureCoords;

      #elif defined(USE_RELIEF_PARALLAX)

      vec2 deltaTexCoord = dtex / 2.0;
      float deltaHeight = layerHeight / 2.0;

      // Return to the mid point of previous layer
      currentTextureCoords += deltaTexCoord;
      currentLayerHeight -= deltaHeight;

      // Binary search to increase precision of Steep Parallax Mapping
      const int numSearches = 5;
      for (int i = 0; i < numSearches; i += 1) {
        deltaTexCoord /= 2.0;
        deltaHeight /= 2.0;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
        // Shift along or against vector V
        if (heightFromTexture > currentLayerHeight) {
          // Below the surface

          currentTextureCoords -= deltaTexCoord;
          currentLayerHeight += deltaHeight;
        } else {
          // above the surface

          currentTextureCoords += deltaTexCoord;
          currentLayerHeight -= deltaHeight;
        }
      }
      return currentTextureCoords;

      #elif defined(USE_OCLUSION_PARALLAX)

      vec2 prevTCoords = currentTextureCoords + dtex;

      // Heights for linear interpolation
      float nextH = heightFromTexture - currentLayerHeight;
      float prevH = texture2D(bumpMap, prevTCoords).r - currentLayerHeight + layerHeight;

      // Proportions for linear interpolation
      float weight = nextH / (nextH - prevH);

      // Interpolation of texture coordinates
      return prevTCoords * weight + currentTextureCoords * (1.0 - weight);

      #else // NO_PARALLAX

      return vUv;

      #endif
    }
    #endif

    vec2 perturbUv(vec3 surfPosition, vec3 surfNormal, vec3 viewPosition) {
      vec2 texDx = dFdx(vUv);
      vec2 texDy = dFdy(vUv);

      vec3 vSigmaX = dFdx(surfPosition);
      vec3 vSigmaY = dFdy(surfPosition);
      vec3 vR1 = cross(vSigmaY, surfNormal);
      vec3 vR2 = cross(surfNormal, vSigmaX);
      float fDet = dot(vSigmaX, vR1);

      vec2 vProjVscr = (1.0 / fDet) * vec2(dot(vR1, viewPosition), dot(vR2, viewPosition));
      vec3 vProjVtex;
      vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;
      vProjVtex.z = dot(surfNormal, viewPosition);

      return parallaxMap(vProjVtex);
    }

    void main() {
      vec2 mapUv = perturbUv(-vViewPosition, normalize(vNormal), normalize(vViewPosition));
      
      // CUSTOM START
      vec4 texel = texture2D(map, mapUv);
      vec3 color = mix(texel.xyz, vec3(0), fade);
      gl_FragColor = vec4(color, 1.0);
      // CUSTOM END
    }

  `},p=new THREE.Vector3,m=new THREE.Vector3(0,0,1);AFRAME.registerComponent("parallax",{schema:{strength:{type:"number",default:.5},cutoffTransition:{type:"number",default:Math.PI/8},cutoffAngle:{type:"number",default:Math.PI/4}},init:function(){const t=this.el.object3DMap.mesh,{map:e,emissiveMap:i}=t.material;e.wrapS=e.wrapT=THREE.ClampToEdgeWrapping,i.wrapS=i.wrapT=THREE.ClampToEdgeWrapping;const{vertexShader:a,fragmentShader:r}=d;this.material=new THREE.ShaderMaterial({vertexShader:a,fragmentShader:r,defines:{USE_OCLUSION_PARALLAX:!0},uniforms:{map:{value:e},bumpMap:{value:i},parallaxScale:{value:-1*this.data.strength},parallaxMinLayers:{value:20},parallaxMaxLayers:{value:30},fade:{value:0}}}),t.material=this.material},tick(){if(this.el.sceneEl.camera){this.el.sceneEl.camera.getWorldPosition(p),this.el.object3D.worldToLocal(p);const l=p.angleTo(m),c=(t=l,e=this.data.cutoffAngle-this.data.cutoffTransition,i=this.data.cutoffAngle+this.data.cutoffTransition,s=function(t,e,i,a,r){return a+(t-e)*(r-a)/(i-e)}(t,e,i,a=0,r=1),n=a,o=r,Math.max(n,Math.min(o,s)));this.material.uniforms.fade.value=c}var t,e,i,a,r,s,n,o}}),AFRAME.registerComponent("html-script",{schema:{name:{type:"string",default:""}},init:function(){this.script=null,this.fullName=this.data.name,this.parseNodeName(),this.createScript()},update:function(){""!==this.data.name&&this.data.name!==this.fullName&&(this.fullName=this.data.name,this.parseNodeName(),this.script&&this.destroyScript(),this.createScript())},createScript:function(){this.loadScript().then((()=>{if(this.script){this.script.isNetworked&&(this.netEntity=null,this.getSharedData=this.getSharedData.bind(this),this.takeOwnership=this.takeOwnership.bind(this),this.setSharedData=this.setSharedData.bind(this),this.script.setNetworkMethods(this.takeOwnership,this.setSharedData)),this.simpleContainer=new THREE.Object3D,this.simpleContainer.matrixAutoUpdate=!0,this.simpleContainer.add(this.script.webLayer3D);var t=this.el.parentEl.parentEl.object3D,e=t.scale.x,i=t.scale.y;if(t.scale.x=1,t.scale.y=1,e&&e>0&&i&&i>0){var a=(new THREE.Box3).setFromObject(this.script.webLayer3D),r=a.max.x-a.min.x,s=a.max.y-a.min.y,n=Math.min(e/r,i/s);this.simpleContainer.scale.set(n,n,n)}this.el.object3D.children.pop(),this.script.isStatic&&(this.script.isInteractive||this.script.isNetworked)&&(this.script.isStatic=!1),this.el.object3D.add(this.simpleContainer),this.script.isStatic||setInterval((()=>{this.script.webLayer3D.refresh(!0),this.script.webLayer3D.update(!0)}),50),this.script.isInteractive&&(this.el.setAttribute("is-remote-hover-target",""),this.el.setAttribute("tags",{singleActionButton:!0}),this.el.classList.add("interactable"),this.clicked=this.clicked.bind(this),this.el.object3D.addEventListener("interact",this.clicked),this.raycaster=new THREE.Raycaster,this.hoverRayL=new THREE.Ray,this.hoverRayR=new THREE.Ray),this.script.isNetworked&&(this.setupNetworkedEntity=function(t){var e,i,a=!0;t?(e=NAF.utils.getNetworkId(t)+"-html-script",a=i.components.networked.data.persistent):e=this.fullName.replaceAll("_","-")+"-html-script",NAF.entities.hasEntity(e)?i=NAF.entities.getEntity(e):((i=document.createElement("a-entity")).getSharedData=this.getSharedData,i.setAttribute("networked",{template:"#script-data-media",persistent:a,owner:"scene",networkId:e}),this.el.sceneEl.appendChild(i)),this.netEntity=i,NAF.utils.getNetworkedEntity(this.netEntity).then((t=>{this.stateSync=t.components["script-data"],0===this.stateSync.sharedData&&t.components.networked}))},this.setupNetworkedEntity=this.setupNetworkedEntity.bind(this),this.setupNetworked=function(){NAF.utils.getNetworkedEntity(this.el).then((t=>{this.setupNetworkedEntity(t)})).catch((()=>{this.setupNetworkedEntity()}))},this.setupNetworked=this.setupNetworked.bind(this),NAF.connection&&NAF.connection.isConnected()?this.setupNetworked():this.el.sceneEl.addEventListener("didConnectToNetworkedScene",this.setupNetworked))}}))},play:function(){this.script&&this.script.play()},pause:function(){this.script&&this.script.pause()},clicked:function(t){const e=t.object3D;this.raycaster.ray.set(e.position,this.script.webLayer3D.getWorldDirection(new THREE.Vector3).negate());const i=this.script.webLayer3D.hitTest(this.raycaster.ray);i&&(i.target.click(),i.target.focus(),console.log("hit",i.target,i.layer))},takeOwnership:function(){return!this.stateSync||this.stateSync.takeOwnership()},setSharedData:function(t){return!this.stateSync||this.stateSync.setSharedData(t)},getSharedData:function(){return this.script?this.script.getSharedData():(console.warn("script-data component called parent element but there is no script yet?"),"{}")},tick:function(t){if(this.script){if(this.script.isInteractive){const t=this.el.sceneEl.systems["hubs-systems"].cursorTogglingSystem;var e=[];let i,a;const r=this.el.sceneEl.systems.interaction;if(!r.ready)return;if(r.state.leftHand.hovered!==this.el||r.state.leftHand.held||(i=r.options.leftHand.entity.object3D),r.state.leftRemote.hovered!==this.el||r.state.leftRemote.held||t.leftToggledOff||(i=r.options.leftRemote.entity.object3D),i){let t=i.position,a=this.script.webLayer3D.getWorldDirection(new THREE.Vector3).negate();t.addScaledVector(a,-.1),this.hoverRayL.set(t,a),e.push(this.hoverRayL)}if(r.state.rightRemote.hovered!==this.el||r.state.rightRemote.held||t.rightToggledOff||(a=r.options.rightRemote.entity.object3D),r.state.rightHand.hovered!==this.el||r.state.rightHand.held||(a=r.options.rightHand.entity.object3D),a){let t=a.position,i=this.script.webLayer3D.getWorldDirection(new THREE.Vector3).negate();t.addScaledVector(i,-.1),this.hoverRayR.set(t,i),e.push(this.hoverRayR)}this.script.webLayer3D.interactionRays=e}if(this.script.isNetworked){if(!this.netEntity||!this.stateSync)return;this.stateSync.changed&&(this.stateSync.changed=!1,this.script.updateSharedData(this.stateSync.dataObject))}}},parseNodeName:function(){""===this.fullName&&(this.fullName=this.el.parentEl.parentEl.className);const t=this.fullName.match(/_([A-Za-z0-9]*)$/);!t||t.length<2?(console.warn("html-script componentName not formatted correctly: ",this.fullName),this.componentName=null):this.componentName=t[1]},loadScript:async function(){var e=t[this.componentName];if(!e)return console.warn("'html-script' component doesn't have script for "+this.componentName),void(this.script=null);this.script=e(),this.script?(this.script.webLayer3D.refresh(!0),this.script.webLayer3D.update(!0)):console.warn("'html-script' component failed to initialize script for "+this.componentName)},destroyScript:function(){this.script.isInteractive&&(this.el.removeAttribute("is-remote-hover-target"),this.el.removeAttribute("tags"),this.el.classList.remove("interactable"),this.el.object3D.removeEventListener("interact",this.clicked)),this.el.object3D.remove(this.simpleContainer),this.simpleContainer=null,this.script.destroy(),this.script=null}}),AFRAME.registerComponent("script-data",{schema:{scriptdata:{type:"string",default:"{}"}},init:function(){this.takeOwnership=this.takeOwnership.bind(this),this.setSharedData=this.setSharedData.bind(this),this.dataObject=this.el.getSharedData();try{this.sharedData=encodeURIComponent(JSON.stringify(this.dataObject)),this.el.setAttribute("script-data","scriptdata",this.sharedData)}catch(t){console.error("Couldn't encode initial script data object: ",t,this.dataObject),this.sharedData="{}",this.dataObject={}}this.changed=!1},update(){if(this.changed=!(this.sharedData===this.data.scriptdata),this.changed)try{this.dataObject=JSON.parse(decodeURIComponent(this.data.scriptdata)),this.sharedData=this.data.scriptdata,this.changed=!0}catch(t){console.error("couldn't parse JSON received in script-sync: ",t),this.sharedData="",this.dataObject={}}},play(){this.el.components.networked&&APP.utils&&APP.utils.applyPersistentSync(this.el.components.networked.data.networkId)},takeOwnership(){return!(!NAF.utils.isMine(this.el)&&!NAF.utils.takeOwnership(this.el))},setSharedData(t){if(!NAF.utils.isMine(this.el)&&!NAF.utils.takeOwnership(this.el))return!1;try{var e=encodeURIComponent(JSON.stringify(t));return this.sharedData=e,this.dataObject=t,this.el.setAttribute("script-data","scriptdata",e),!0}catch(t){return console.error("can't stringify the object passed to script-sync"),!1}}});document.querySelector("a-assets").insertAdjacentHTML("beforeend",'\n    <template id="script-data-media">\n      <a-entity\n        script-data\n      ></a-entity>\n    </template>\n  '),NAF.schemas.add({template:"#script-data-media",components:[{component:"script-data",property:"scriptdata"}],nonAuthorizedComponents:[{component:"script-data",property:"scriptdata"}]}),AFRAME.GLTFModelPlus.registerComponent("immersive-360","immersive-360"),AFRAME.GLTFModelPlus.registerComponent("portal","portal"),AFRAME.GLTFModelPlus.registerComponent("parallax","parallax"),AFRAME.GLTFModelPlus.registerComponent("html-script","html-script");
