import*as e from"https://resources.realitymedia.digital/test-vue-app/dist/hubs.js";AFRAME.registerSystem("fader-plus",{schema:{direction:{type:"string",default:"none"},duration:{type:"number",default:200},color:{type:"color",default:"white"}},init(){const e=new THREE.Mesh(new THREE.BoxGeometry,new THREE.MeshBasicMaterial({color:this.data.color,side:THREE.BackSide,opacity:0,transparent:!0,fog:!1}));e.scale.x=e.scale.y=1,e.scale.z=.15,e.matrixNeedsUpdate=!0,e.renderOrder=1,this.el.camera.add(e),this.mesh=e},fadeOut(){return this.beginTransition("out")},fadeIn(){return this.beginTransition("in")},async beginTransition(e){if(this._resolveFinish)throw new Error("Cannot fade while a fade is happening.");return this.el.setAttribute("fader-plus",{direction:e}),new Promise((t=>{this.mesh.material.opacity===("in"==e?0:1)?t():this._resolveFinish=t}))},tick(e,t){const i=this.mesh.material;this.mesh.visible="out"===this.data.direction||0!==i.opacity,this.mesh.visible&&("in"===this.data.direction?i.opacity=Math.max(0,i.opacity-1/this.data.duration*Math.min(t,50)):"out"===this.data.direction&&(i.opacity=Math.min(1,i.opacity+1/this.data.duration*Math.min(t,50))),0!==i.opacity&&1!==i.opacity||("none"!==this.data.direction&&this._resolveFinish&&(this._resolveFinish(),this._resolveFinish=null),this.el.setAttribute("fader-plus",{direction:"none"})))}});const t=new THREE.Vector3,i=new THREE.Vector3;AFRAME.registerComponent("proximity-events",{schema:{radius:{type:"number",default:1}},init(){this.inZone=!1,this.camera=this.el.sceneEl.camera},tick(){this.camera.getWorldPosition(t),this.el.object3D.getWorldPosition(i);const e=this.inZone;this.inZone=t.distanceTo(i)<this.data.radius,this.inZone&&!e&&this.el.emit("proximityenter"),!this.inZone&&e&&this.el.emit("proximityleave")}});const a=new THREE.Vector3,r=new THREE.Vector3,n=new THREE.Vector3,o=new THREE.Quaternion,s=new THREE.Matrix4;AFRAME.registerSystem("portal",{dependencies:["fader-plus"],init:function(){this.teleporting=!1,this.characterController=this.el.systems["hubs-systems"].characterController,this.fader=this.el.systems["fader-plus"],this.roomData=null,this.waitForFetch=this.waitForFetch.bind(this),window.APP.store.state.credentials&&window.APP.store.state.credentials.token&&!window.APP.userData&&this.fetchRoomData()},fetchRoomData:async function(){var e={token:window.APP.store.state.credentials.token,room_id:window.APP.hubChannel.hubId};const t={};t.headers=new Headers,t.headers.set("Authorization",`Bearer ${e}`),t.headers.set("Content-Type","application/json"),await fetch("https://realitymedia.digital/userData",t).then((e=>e.json())).then((e=>{console.log("Success:",e),this.roomData=e})),this.roomData.textures=[]},getRoomURL:async function(e){return this.waitForFetch(),this.roomData.rooms.length>e?"https://xr.realitymedia.digital/"+this.roomData.rooms[e]:null},getCubeMap:async function(e){return this.waitForFetch(),this.roomData.cubemaps.length>e?this.roomData.cubemaps[e]:null},waitForFetch:function(){this.roomData||setTimeout(this.waitForFetch,100)},teleportTo:async function(e){this.teleporting=!0,await this.fader.fadeOut(),e.getWorldQuaternion(o),e.getWorldDirection(n),e.getWorldPosition(a),a.add(n.multiplyScalar(1.5)),s.makeRotationFromQuaternion(o),s.setPosition(a),this.characterController.travelByWaypoint(s,!0,!1),await this.fader.fadeIn(),this.teleporting=!1}}),AFRAME.registerComponent("portal",{schema:{color:{type:"color",default:null}},init:async function(){this.system=APP.scene.systems.portal,this.parseNodeName(),this.material=new THREE.ShaderMaterial({transparent:!0,side:THREE.DoubleSide,uniforms:{cubeMap:{value:new THREE.Texture},time:{value:0},radius:{value:0},ringColor:{value:this.color}},vertexShader:"\nvarying vec2 vUv;\nvarying vec3 vRay;\nvarying vec3 vNormal;\n\nvoid main() {\n  vUv = uv;\n  // vNormal = normalMatrix * normal;\n  vec3 cameraLocal = (inverse(modelMatrix) * vec4(cameraPosition, 1.0)).xyz;\n  vRay = position - cameraLocal;\n  vNormal = normalize(-1. * vRay);\n  float dist = length(cameraLocal);\n  vRay.z *= 1.3 / (1. + pow(dist, 0.5)); // Change FOV by squashing local Z direction\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\n        \n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }  \n\n        \nuniform samplerCube cubeMap;\nuniform float time;\nuniform float radius;\nuniform vec3 ringColor;\n\nvarying vec2 vUv;\nvarying vec3 vRay;\nvarying vec3 vNormal;\n\n#define RING_WIDTH 0.1\n#define RING_HARD_OUTER 0.01\n#define RING_HARD_INNER 0.08\n#define forward vec3(0.0, 0.0, 1.0)\n\nvoid main() {\n  vec2 coord = vUv * 2.0 - 1.0;\n  float noise = snoise(vec3(coord * 1., time)) * 0.5 + 0.5;\n\n  // Polar distance\n  float dist = length(coord);\n  dist += noise * 0.2;\n\n  float maskOuter = 1.0 - smoothstep(radius - RING_HARD_OUTER, radius, dist);\n  float maskInner = 1.0 - smoothstep(radius - RING_WIDTH, radius - RING_WIDTH + RING_HARD_INNER, dist);\n  float distortion = smoothstep(radius - 0.2, radius + 0.2, dist);\n  vec3 normal = normalize(vNormal);\n  float directView = smoothstep(0., 0.8, dot(normal, forward));\n  vec3 tangentOutward = vec3(coord, 0.0);\n  vec3 ray = mix(vRay, tangentOutward, distortion);\n  vec4 texel = textureCube(cubeMap, ray);\n  vec3 centerLayer = texel.rgb * maskInner;\n  vec3 ringLayer = ringColor * (1. - maskInner);\n  vec3 composite = centerLayer + ringLayer;\n\n  gl_FragColor = vec4(composite, (maskOuter - maskInner) + maskInner * directView);\n}\n\n      "});this.el.getOrCreateObject3D("mesh").material=this.material,this.other=await this.getOther(),1==this.portalType?this.system.getCubeMap(this.portalTarget).then((e=>{new Promise(((t,i)=>(new THREE.CubeTextureLoader).load(e,t,void 0,i))).then((e=>{e.format=THREE.RGBFormat,this.material.uniforms.cubeMap.value=e})).catch((e=>console.error(e)))})):2==this.portalType&&(this.cubeCamera=new THREE.CubeCamera(1,1e5,1024),this.cubeCamera.rotateY(Math.PI),this.el.object3D.add(this.cubeCamera),this.other.components.portal.material.uniforms.cubeMap.value=this.cubeCamera.renderTarget.texture,this.el.sceneEl.addEventListener("model-loaded",(()=>{this.cubeCamera.update(this.el.sceneEl.renderer,this.el.sceneEl.object3D)}))),this.el.setAttribute("animation__portal",{property:"components.portal.material.uniforms.radius.value",dur:700,easing:"easeInOutCubic"}),this.el.addEventListener("animationbegin",(()=>this.el.object3D.visible=!0)),this.el.addEventListener("animationcomplete__portal",(()=>this.el.object3D.visible=!this.isClosed())),this.el.setAttribute("is-remote-hover-target",""),this.el.setAttribute("tags",{singleActionButton:!0}),this.el.setAttribute("class","interactable"),this.followPortal=this.followPortal.bind(this),this.el.object3D.addEventListener("interact",this.followPortal),this.el.setAttribute("proximity-events",{radius:5}),this.el.addEventListener("proximityenter",(()=>this.open())),this.el.addEventListener("proximityleave",(()=>this.close()))},followPortal:function(){1==this.portalType?(console.log("set window.location.href to "+this.other),window.location.href=this.other):2==this.portalType&&this.system.teleportTo(this.other.object3D)},tick:function(e){if(this.material.uniforms.time.value=e/1e3,this.other&&!this.system.teleporting){this.el.object3D.getWorldPosition(a),this.el.sceneEl.camera.getWorldPosition(r);const e=r.distanceTo(a);1==this.portalType&&e<.5||2==this.portalType&&e<1&&this.system.teleportTo(this.other.object3D)}},getOther:function(){return new Promise((e=>{0==this.portalType&&e(null),1==this.portalType&&this.system.getRoomURL(this.portalTarget).then((t=>{e(t)}));const t=Array.from(document.querySelectorAll("[portal]")).find((e=>e.components.portal.portalType==this.portalType&&e.components.portal.portalTarget===this.portalTarget&&e!==this.el));void 0!==t?(e(t),t.emit("pair",{other:this.el})):this.el.addEventListener("pair",(t=>e(t.detail.other)),{once:!0})}))},parseNodeName:function(){const e=this.el.parentEl.parentEl.className,t=e.match(/([A-Za-z]*)_([A-Za-z0-9]*)_([A-Za-z0-9]*)$/);if(!t||t.length<4)return console.warn("portal node name not formed correctly: ",e),this.portalType=0,this.portalTarget=null,void(this.color="red");"room"===t[1]?(this.portalType=1,this.portalTarget=parseInt(t[2])):"portal"===t[1]?(this.portalType=2,this.portalTarget=t[2]):(this.portalType=0,this.portalTarget=null),this.color=new THREE.Color(t[3])},setRadius(e){this.el.setAttribute("animation__portal",{from:this.material.uniforms.radius.value,to:e})},open(){this.setRadius(1)},close(){this.setRadius(0)},isClosed(){return 0===this.material.uniforms.radius.value}});const l=new THREE.Vector3,c=new THREE.Vector3;AFRAME.registerComponent("immersive-360",{schema:{url:{type:"string",default:null}},init:async function(){const e=this.data.url??this.parseSpokeName(),t=e.match(/^.*\.(.*)$/)[1];this.el.setAttribute("media-image",{projection:"360-equirectangular",alphaMode:"opaque",src:e,version:1,batch:!1,contentType:`image/${t}`,alphaCutoff:0}),this.mesh=await this.getMesh(),this.mesh.geometry.scale(100,100,100),this.mesh.material.setValues({transparent:!0,depthTest:!1}),this.near=1,this.far=1.3,this.mesh.renderOrder=APP.RENDER_ORDER.CURSOR-1},tick:function(){if(this.mesh){this.mesh.getWorldPosition(c),this.el.sceneEl.camera.getWorldPosition(l);const e=1-(c.distanceTo(l)-this.near)/(this.far-this.near);this.mesh.material.opacity=e}},parseSpokeName:function(){const e=this.el.parentEl.parentEl.className,[,t,i]=e.match(/(?:.*__)?(.*)_(.*)/);return`https://gt-ael-aq-assets.aelatgt-internal.net/files/${t}.${i}`},getMesh:async function(){return new Promise((e=>{const t=this.el.object3DMap.mesh;t&&e(t),this.el.addEventListener("image-loaded",(()=>{e(this.el.object3DMap.mesh)}),{once:!0})}))}});const h=String.raw,m={modes:{none:"NO_PARALLAX",basic:"USE_BASIC_PARALLAX",steep:"USE_STEEP_PARALLAX",occlusion:"USE_OCLUSION_PARALLAX",relief:"USE_RELIEF_PARALLAX"},uniforms:{bumpMap:{value:null},map:{value:null},parallaxScale:{value:null},parallaxMinLayers:{value:null},parallaxMaxLayers:{value:null}},vertexShader:h`
    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    void main() {
      vUv = uv;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      vViewPosition = -mvPosition.xyz;
      vNormal = normalize( normalMatrix * normal );
      
      gl_Position = projectionMatrix * mvPosition;
    }
  `,fragmentShader:h`
    uniform sampler2D bumpMap;
    uniform sampler2D map;

    uniform float parallaxScale;
    uniform float parallaxMinLayers;
    uniform float parallaxMaxLayers;
    uniform float fade; // CUSTOM

    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    #ifdef USE_BASIC_PARALLAX

    vec2 parallaxMap(in vec3 V) {
      float initialHeight = texture2D(bumpMap, vUv).r;

      // No Offset Limitting: messy, floating output at grazing angles.
      //"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

      // Offset Limiting
      vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;
      return vUv - texCoordOffset;
    }

    #else

    vec2 parallaxMap(in vec3 V) {
      // Determine number of layers from angle between V and N
      float numLayers = mix(parallaxMaxLayers, parallaxMinLayers, abs(dot(vec3(0.0, 0.0, 1.0), V)));

      float layerHeight = 1.0 / numLayers;
      float currentLayerHeight = 0.0;
      // Shift of texture coordinates for each iteration
      vec2 dtex = parallaxScale * V.xy / V.z / numLayers;

      vec2 currentTextureCoords = vUv;

      float heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;

      // while ( heightFromTexture > currentLayerHeight )
      // Infinite loops are not well supported. Do a "large" finite
      // loop, but not too large, as it slows down some compilers.
      for (int i = 0; i < 30; i += 1) {
        if (heightFromTexture <= currentLayerHeight) {
          break;
        }
        currentLayerHeight += layerHeight;
        // Shift texture coordinates along vector V
        currentTextureCoords -= dtex;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
      }

      #ifdef USE_STEEP_PARALLAX

      return currentTextureCoords;

      #elif defined(USE_RELIEF_PARALLAX)

      vec2 deltaTexCoord = dtex / 2.0;
      float deltaHeight = layerHeight / 2.0;

      // Return to the mid point of previous layer
      currentTextureCoords += deltaTexCoord;
      currentLayerHeight -= deltaHeight;

      // Binary search to increase precision of Steep Parallax Mapping
      const int numSearches = 5;
      for (int i = 0; i < numSearches; i += 1) {
        deltaTexCoord /= 2.0;
        deltaHeight /= 2.0;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
        // Shift along or against vector V
        if (heightFromTexture > currentLayerHeight) {
          // Below the surface

          currentTextureCoords -= deltaTexCoord;
          currentLayerHeight += deltaHeight;
        } else {
          // above the surface

          currentTextureCoords += deltaTexCoord;
          currentLayerHeight -= deltaHeight;
        }
      }
      return currentTextureCoords;

      #elif defined(USE_OCLUSION_PARALLAX)

      vec2 prevTCoords = currentTextureCoords + dtex;

      // Heights for linear interpolation
      float nextH = heightFromTexture - currentLayerHeight;
      float prevH = texture2D(bumpMap, prevTCoords).r - currentLayerHeight + layerHeight;

      // Proportions for linear interpolation
      float weight = nextH / (nextH - prevH);

      // Interpolation of texture coordinates
      return prevTCoords * weight + currentTextureCoords * (1.0 - weight);

      #else // NO_PARALLAX

      return vUv;

      #endif
    }
    #endif

    vec2 perturbUv(vec3 surfPosition, vec3 surfNormal, vec3 viewPosition) {
      vec2 texDx = dFdx(vUv);
      vec2 texDy = dFdy(vUv);

      vec3 vSigmaX = dFdx(surfPosition);
      vec3 vSigmaY = dFdy(surfPosition);
      vec3 vR1 = cross(vSigmaY, surfNormal);
      vec3 vR2 = cross(surfNormal, vSigmaX);
      float fDet = dot(vSigmaX, vR1);

      vec2 vProjVscr = (1.0 / fDet) * vec2(dot(vR1, viewPosition), dot(vR2, viewPosition));
      vec3 vProjVtex;
      vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;
      vProjVtex.z = dot(surfNormal, viewPosition);

      return parallaxMap(vProjVtex);
    }

    void main() {
      vec2 mapUv = perturbUv(-vViewPosition, normalize(vNormal), normalize(vViewPosition));
      
      // CUSTOM START
      vec4 texel = texture2D(map, mapUv);
      vec3 color = mix(texel.xyz, vec3(0), fade);
      gl_FragColor = vec4(color, 1.0);
      // CUSTOM END
    }

  `},d=new THREE.Vector3,p=new THREE.Vector3(0,0,1);AFRAME.registerComponent("parallax",{schema:{strength:{type:"number",default:.5},cutoffTransition:{type:"number",default:Math.PI/8},cutoffAngle:{type:"number",default:Math.PI/4}},init:function(){const e=this.el.object3DMap.mesh,{map:t,emissiveMap:i}=e.material;t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping,i.wrapS=i.wrapT=THREE.ClampToEdgeWrapping;const{vertexShader:a,fragmentShader:r}=m;this.material=new THREE.ShaderMaterial({vertexShader:a,fragmentShader:r,defines:{USE_OCLUSION_PARALLAX:!0},uniforms:{map:{value:t},bumpMap:{value:i},parallaxScale:{value:-1*this.data.strength},parallaxMinLayers:{value:20},parallaxMaxLayers:{value:30},fade:{value:0}}}),e.material=this.material},tick(){if(this.el.sceneEl.camera){this.el.sceneEl.camera.getWorldPosition(d),this.el.object3D.worldToLocal(d);const l=d.angleTo(p),c=(e=l,t=this.data.cutoffAngle-this.data.cutoffTransition,i=this.data.cutoffAngle+this.data.cutoffTransition,n=function(e,t,i,a,r){return a+(e-t)*(r-a)/(i-t)}(e,t,i,a=0,r=1),o=a,s=r,Math.max(o,Math.min(s,n)));this.material.uniforms.fade.value=c}var e,t,i,a,r,n,o,s}}),AFRAME.registerComponent("html-script",{init:function(){this.parseNodeName().then((()=>{if(!this.scriptData)return;this.simpleContainer=new THREE.Object3D,this.simpleContainer.matrixAutoUpdate=!0,this.simpleContainer.add(this.scriptData.webLayer3D),this.scriptData.webLayer3D._webLayer._hashingCanvas.width=20,this.scriptData.webLayer3D._webLayer._hashingCanvas.height=20;const e=this.scriptData.width,t=this.scriptData.height;if(e&&e>0&&t&&t>0){var i=(new THREE.Box3).setFromObject(this.scriptData.webLayer3D),a=i.max.x-i.min.x,r=i.max.y-i.min.y,n=Math.max(e/a,t/r);this.simpleContainer.scale.set(n,n,n)}this.el.object3D.add(this.simpleContainer),setInterval((()=>{this.scriptData.webLayer3D.refresh(!0),this.scriptData.webLayer3D.update(!0)}),50),this.el.setAttribute("is-remote-hover-target",""),this.el.setAttribute("tags",{singleActionButton:!0}),this.el.setAttribute("class","interactable"),this.clicked=this.clicked.bind(this),this.el.object3D.addEventListener("interact",this.clicked),this.raycaster=new THREE.Raycaster,this.hoverRayL=new THREE.Ray,this.hoverRayR=new THREE.Ray}))},clicked:function(e){const t=e.object3D;this.raycaster.ray.set(t.position,this.scriptData.webLayer3D.getWorldDirection(new THREE.Vector3).negate());const i=this.scriptData.webLayer3D.hitTest(this.raycaster.ray);i&&(i.target.click(),i.target.focus(),console.log("hit",i.target,i.layer))},tick:function(e){const t=this.el.sceneEl.systems["hubs-systems"].cursorTogglingSystem;var i=[];let a,r;const n=this.el.sceneEl.systems.interaction;if(n.ready){if(n.state.leftHand.hovered!==this.el||n.state.leftHand.held||(a=n.options.leftHand.entity.object3D),n.state.leftRemote.hovered!==this.el||n.state.leftRemote.held||t.leftToggledOff||(a=n.options.leftRemote.entity.object3D),a){let e=a.position,t=this.scriptData.webLayer3D.getWorldDirection(new THREE.Vector3).negate();e.addScaledVector(t,-.1),this.hoverRayL.set(e,t),i.push(this.hoverRayL)}if(n.state.rightRemote.hovered!==this.el||n.state.rightRemote.held||t.rightToggledOff||(r=n.options.rightRemote.entity.object3D),n.state.rightHand.hovered!==this.el||n.state.rightHand.held||(r=n.options.rightHand.entity.object3D),r){let e=r.position,t=this.scriptData.webLayer3D.getWorldDirection(new THREE.Vector3).negate();e.addScaledVector(t,-.1),this.hoverRayR.set(e,t),i.push(this.hoverRayR)}this.scriptData.webLayer3D.interactionRays=i}},parseNodeName:async function(){const t=this.el.parentEl.parentEl.className,i=t.match(/([A-Za-z0-9]*)_([A-Za-z0-9]*)$/);if(!i||i.length<3)console.warn("html-script dirname_filename not formatted correctly: ",t),this.dirname=null,this.filename=null,this.scriptData=null;else{this.dirname=i[1],this.filename=i[2];var a=e[this.filename];if(!a)return console.warn("'html-script' component doesn't have script for "+t),void(this.scriptData=null);this.scriptData=a(),this.scriptData?(this.scriptData.webLayer3D._webLayer._hashingCanvas.width=200,this.scriptData.webLayer3D._webLayer._hashingCanvas.height=200,this.scriptData.webLayer3D.refresh(!0),this.scriptData.webLayer3D.update(!0)):console.warn("'html-script' component failed to initialize script for "+t)}}}),AFRAME.GLTFModelPlus.registerComponent("immersive-360","immersive-360"),AFRAME.GLTFModelPlus.registerComponent("portal","portal"),AFRAME.GLTFModelPlus.registerComponent("parallax","parallax"),AFRAME.GLTFModelPlus.registerComponent("html-script","html-script");
