import*as e from"https://resources.realitymedia.digital/vue-apps/dist/hubs.js";AFRAME.registerSystem("fader-plus",{schema:{direction:{type:"string",default:"none"},duration:{type:"number",default:200},color:{type:"color",default:"white"}},init(){const e=new THREE.Mesh(new THREE.BoxGeometry,new THREE.MeshBasicMaterial({color:this.data.color,side:THREE.BackSide,opacity:0,transparent:!0,fog:!1}));e.scale.x=e.scale.y=1,e.scale.z=.15,e.matrixNeedsUpdate=!0,e.renderOrder=1,this.el.camera.add(e),this.mesh=e},fadeOut(){return this.beginTransition("out")},fadeIn(){return this.beginTransition("in")},async beginTransition(e){if(this._resolveFinish)throw new Error("Cannot fade while a fade is happening.");return this.el.setAttribute("fader-plus",{direction:e}),new Promise((t=>{this.mesh.material.opacity===("in"==e?0:1)?t():this._resolveFinish=t}))},tick(e,t){const i=this.mesh.material;this.mesh.visible="out"===this.data.direction||0!==i.opacity,this.mesh.visible&&("in"===this.data.direction?i.opacity=Math.max(0,i.opacity-1/this.data.duration*Math.min(t,50)):"out"===this.data.direction&&(i.opacity=Math.min(1,i.opacity+1/this.data.duration*Math.min(t,50))),0!==i.opacity&&1!==i.opacity||("none"!==this.data.direction&&this._resolveFinish&&(this._resolveFinish(),this._resolveFinish=null),this.el.setAttribute("fader-plus",{direction:"none"})))}});const t=new THREE.Vector3,i=new THREE.Vector3;AFRAME.registerComponent("proximity-events",{schema:{radius:{type:"number",default:1}},init(){this.inZone=!1,this.camera=this.el.sceneEl.camera},tick(){this.camera.getWorldPosition(t),this.el.object3D.getWorldPosition(i);const e=this.inZone;this.inZone=t.distanceTo(i)<this.data.radius,this.inZone&&!e&&this.el.emit("proximityenter"),!this.inZone&&e&&this.el.emit("proximityleave")}});function a(e,t){window.APP.componentRegistry=window.APP.componentRegistry||{},window.APP.componentRegistry[t]=window.APP.componentRegistry[t]||[],window.APP.componentRegistry[t].push(e)}function o(e,t){window.APP.componentRegistry&&window.APP.componentRegistry[t]&&window.APP.componentRegistry[t].splice(window.APP.componentRegistry[t].indexOf(e),1)}function r(e,t){for(;e&&(!e.components||!e.components[t]);)e=e.parentNode;return e}let n=function(e,t){let i=t.position;return 1e6*(Math.floor(i.x/e)+5e5)+(Math.floor(i.z/e)+5e5)},s=[];function l(e){let t=e;for(;t&&t.components&&!t.components["object-region-follower"];)t=t.parentNode;if(t&&t.components&&t.components["object-region-follower"])return t.components["object-region-follower"]}function c(e){s[e]?s[e]++:s[e]=1,console.log("Avatars in region "+e+": "+s[e]),1==s[e]?h(e,!0):console.log("already another avatar in this region, no change")}function m(e){s[e]&&s[e]--,console.log("Avatars left region "+e+": "+s[e]),0==s[e]?h(e,!1):console.log("still another avatar in this region, no change")}function h(e,t){if(!window.APP||!window.APP.componentRegistry)return null;console.log((t?"showing":"hiding")+" all objects in region "+e);const i=window.APP.componentRegistry["object-region-follower"]||[];for(let a=0;a<i.length;a++){const o=i[a];o.region==e&&(console.log((t?"showing ":" hiding")+o.el.className),o.showHide(t))}return null}AFRAME.registerComponent("avatar-region-follower",{schema:{size:{default:10}},init:function(){this.region=n(this.data.size,this.el.object3D),console.log("Avatar: region ",this.region),c(this.region),a(this,"avatar-region-follower")},remove:function(){o(this,"avatar-region-follower"),m(this.region)},tick:function(){let e=n(this.data.size,this.el.object3D);e!=this.region&&(m(this.region),c(e),this.region=e)}}),AFRAME.registerComponent("object-region-follower",{schema:{size:{default:10},dynamic:{default:!0}},init:function(){this.region=n(this.data.size,this.el.object3D),this.showHide=this.showHide.bind(this),this.el.components["media-video"]&&(this.wasPaused=this.el.components["media-video"].data.videoPaused),a(this,"object-region-follower")},remove:function(){o(this,"object-region-follower")},tick:function(){if(!this.data.dynamic)return;this.region=n(this.data.size,this.el.object3D);let e=!!s[this.region];this.el.object3D.visible!=e&&this.showHide(e)},showHide:function(e){this.el.object3D.visible=e,this.el.components["media-video"]&&(e?this.wasPaused!=this.el.components["media-video"].data.videoPaused&&this.el.components["media-video"].togglePlaying():(this.wasPaused=this.el.components["media-video"].data.videoPaused,this.wasPaused||this.el.components["media-video"].togglePlaying()))}}),AFRAME.registerComponent("region-hider",{schema:{size:{default:10}},init:function(){if(!r(this.el,"nav-mesh-helper"))return console.warn("region-hider component must be in the environment scene glb."),void(this.size=0);0==this.data.size&&(this.data.size=10,this.size=this.parseNodeName(this.data.size));let e=document.getElementsByClassName("RoomObjects");this.roomObjects=e.length>0?e[0]:null;this.el.sceneEl.querySelectorAll("[player-info]").forEach((e=>{e.setAttribute("avatar-region-follower",{size:this.size})}));var t=this.el.sceneEl.querySelectorAll(".RoomObjects > [media-loader]");t.forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})})),(t=this.el.sceneEl.querySelectorAll("[camera-tool], a-scene > [media-loader]")).forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})})),(t=this.el.sceneEl.querySelectorAll("[camera-tool]")).forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})})),this.sceneLoaded=this.sceneLoaded.bind(this),this.el.sceneEl.addEventListener("environment-scene-loaded",this.sceneLoaded)},isAncestor:function(e,t){for(;t&&t!=e;)t=t.parentNode;return t==e},sceneLoaded:function(){let e=document.getElementById("environment-scene").children[0].children[0];for(let i=0;i<e.length;i++){let a=e[i];if(this.isAncestor(a,this.el))continue;let o=a.className;if("CombinedMesh"===o||"scene-preview-camera"===o)continue;let r=a.components;if(r.waypoint||r.skybox||r["directional-light"]||r["ambient-light"]||r["hemisphere-light"])continue;let n=a.children;var t=!1;for(let e=0;e<n.length;e++)if(n[e].components.navmesh){t=!0;break}t||a.setAttribute("object-region-follower",{size:this.size,dynamic:!1})}!function(){if(!window.APP||!window.APP.componentRegistry)return null;console.log("showing/hiding all objects");const e=window.APP.componentRegistry["object-region-follower"]||[];for(let t=0;t<e.length;t++){const i=e[t];let a=!!s[i.region];i.el.object3D.visible!=a&&(console.log((a?"showing ":"hiding ")+i.el.className),i.showHide(a))}}()},update:function(){this.data.size!==this.size&&0==this.data.size&&(this.data.size=10,this.size=this.parseNodeName(this.data.size))},remove:function(){this.el.sceneEl.removeEventListener("environment-scene-loaded",this.sceneLoaded)},tick:function(e){if(0!=this.size){var t=this.el.sceneEl.querySelectorAll("[player-info]:not([avatar-region-follower])");t.forEach((e=>{e.setAttribute("avatar-region-follower",{size:this.size})})),(t=this.el.sceneEl.querySelectorAll("[camera-tool]:not([object-region-follower]), a-scene > [media-loader]:not([object-region-follower])")).forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})}))}},parseNodeName:function(e){this.nodeName=this.el.parentEl.parentEl.className;const t=this.nodeName.match(/_([0-9]*)$/);if(!t||t.length<2)return console.warn("region-hider componentName not formatted correctly: ",this.nodeName),e;{let i=parseInt(t[1]);return i||e}}});const f=new THREE.Vector3,d=new THREE.Vector3,u=new THREE.Vector3,p=new THREE.Quaternion,v=new THREE.Matrix4;AFRAME.registerSystem("portal",{dependencies:["fader-plus"],init:function(){this.teleporting=!1,this.characterController=this.el.systems["hubs-systems"].characterController,this.fader=this.el.systems["fader-plus"],this.roomData=null,this.waitForFetch=this.waitForFetch.bind(this),window.APP.store.state.credentials&&window.APP.store.state.credentials.token&&!window.APP.userData&&this.fetchRoomData()},fetchRoomData:async function(){var e={token:window.APP.store.state.credentials.token,room_id:window.APP.hubChannel.hubId};const t={};t.headers=new Headers,t.headers.set("Authorization",`Bearer ${e}`),t.headers.set("Content-Type","application/json"),await fetch("https://realitymedia.digital/userData",t).then((e=>e.json())).then((e=>{console.log("Success:",e),this.roomData=e})),this.roomData.textures=[]},getRoomURL:async function(e){return this.waitForFetch(),window.SSO.userInfo.rooms.length>e?"https://xr.realitymedia.digital/"+window.SSO.userInfo.rooms[e]:null},getCubeMap:async function(e){return this.waitForFetch(),this.roomData.cubemaps.length>e?this.roomData.cubemaps[e]:null},waitForFetch:function(){this.roomData&&window.SSO.userInfo||setTimeout(this.waitForFetch,100)},teleportTo:async function(e){this.teleporting=!0,await this.fader.fadeOut(),e.getWorldQuaternion(p),e.getWorldDirection(u),e.getWorldPosition(f),f.add(u.multiplyScalar(1.5)),v.makeRotationFromQuaternion(p),v.setPosition(f),this.characterController.travelByWaypoint(v,!0,!1),await this.fader.fadeIn(),this.teleporting=!1}}),AFRAME.registerComponent("portal",{schema:{portalType:{default:""},portalTarget:{default:""},color:{type:"color",default:null},materialTarget:{type:"string",default:null}},init:async function(){if(this.system=window.APP.scene.systems.portal,this.data.portalType.length>0?this.setPortalInfo(this.data.portalType,this.data.portalTarget,this.data.color):this.portalType=0,0==this.portalType&&this.parseNodeName(),this.material=new THREE.ShaderMaterial({transparent:!0,side:THREE.DoubleSide,uniforms:{cubeMap:{value:new THREE.Texture},time:{value:0},radius:{value:0},ringColor:{value:this.color}},vertexShader:"\nvarying vec2 vUv;\nvarying vec3 vRay;\nvarying vec3 vNormal;\n\nvoid main() {\n  vUv = uv;\n  // vNormal = normalMatrix * normal;\n  vec3 cameraLocal = (inverse(modelMatrix) * vec4(cameraPosition, 1.0)).xyz;\n  vRay = position - cameraLocal;\n  vNormal = normalize(-1. * vRay);\n  float dist = length(cameraLocal);\n  vRay.z *= 1.3 / (1. + pow(dist, 0.5)); // Change FOV by squashing local Z direction\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\n        \n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }  \n\n        \nuniform samplerCube cubeMap;\nuniform float time;\nuniform float radius;\nuniform vec3 ringColor;\n\nvarying vec2 vUv;\nvarying vec3 vRay;\nvarying vec3 vNormal;\n\n#define RING_WIDTH 0.1\n#define RING_HARD_OUTER 0.01\n#define RING_HARD_INNER 0.08\n#define forward vec3(0.0, 0.0, 1.0)\n\nvoid main() {\n  vec2 coord = vUv * 2.0 - 1.0;\n  float noise = snoise(vec3(coord * 1., time)) * 0.5 + 0.5;\n\n  // Polar distance\n  float dist = length(coord);\n  dist += noise * 0.2;\n\n  float maskOuter = 1.0 - smoothstep(radius - RING_HARD_OUTER, radius, dist);\n  float maskInner = 1.0 - smoothstep(radius - RING_WIDTH, radius - RING_WIDTH + RING_HARD_INNER, dist);\n  float distortion = smoothstep(radius - 0.2, radius + 0.2, dist);\n  vec3 normal = normalize(vNormal);\n  float directView = smoothstep(0., 0.8, dot(normal, forward));\n  vec3 tangentOutward = vec3(coord, 0.0);\n  vec3 ray = mix(vRay, tangentOutward, distortion);\n  vec4 texel = textureCube(cubeMap, ray);\n  vec3 centerLayer = texel.rgb * maskInner;\n  vec3 ringLayer = ringColor * (1. - maskInner);\n  vec3 composite = centerLayer + ringLayer;\n\n  gl_FragColor = vec4(composite, (maskOuter - maskInner) + maskInner * directView);\n}\n\n      "}),this.replaceMaterial(this.material),this.other=await this.getOther(),1==this.portalType)this.system.getCubeMap(this.portalTarget).then((e=>{new Promise(((t,i)=>(new THREE.CubeTextureLoader).load(e,t,void 0,i))).then((e=>{e.format=THREE.RGBFormat,this.material.uniforms.cubeMap.value=e})).catch((e=>console.error(e)))}));else if(2==this.portalType||3==this.portalType){if(this.cubeCamera=new THREE.CubeCamera(1,1e5,1024),this.cubeCamera.rotateY(Math.PI),2==this.portalType)this.el.object3D.add(this.cubeCamera),this.other.components.portal.material.uniforms.cubeMap.value=this.cubeCamera.renderTarget.texture;else{let e=document.getElementsByClassName(this.portalTarget);e.length>0&&(e=e.item(0),e.object3D.add(this.cubeCamera),this.material.uniforms.cubeMap.value=this.cubeCamera.renderTarget.texture)}this.el.sceneEl.addEventListener("model-loaded",(()=>{!function(e){let t=l(e);t&&(console.log("showing objects near "+t.el.className),c(t.region))}(this.el),this.cubeCamera.update(this.el.sceneEl.renderer,this.el.sceneEl.object3D),function(e){let t=l(e);t&&(console.log("hiding objects near "+t.el.className),m(t.region))}(this.el)}))}this.el.setAttribute("animation__portal",{property:"components.portal.material.uniforms.radius.value",dur:700,easing:"easeInOutCubic"}),this.el.setAttribute("is-remote-hover-target",""),this.el.setAttribute("tags",{singleActionButton:!0}),this.el.setAttribute("proximity-events",{radius:5}),this.el.addEventListener("proximityenter",(()=>this.open())),this.el.addEventListener("proximityleave",(()=>this.close()))},replaceMaterial:function(e){let t=this.data.materialTarget;t&&0==t.length&&(t=null);let i=a=>{let o=a;o.material&&function(e,t){let i=e;if(i.material)Array.isArray(i.material)?i.material.map(t):t(i.material)}(o,(i=>{t&&i.name!==t||(o.material=e)}));const r=a.children;for(let e=0;e<r.length;e++)i(r[e])},a=()=>{var e=this.el.object3DMap.mesh;e||(e=this.el.object3D),i(e),this.el.removeEventListener("model-loaded",n)},o=r(this.el,"gltf-model-plus"),n=()=>{this.el.components["media-loader"]?this.el.addEventListener("media-loaded",a):a()};o.addEventListener("model-loaded",n)},tick:function(e){if(this.material.uniforms.time.value=e/1e3,this.other&&!this.system.teleporting){this.el.object3D.getWorldPosition(f),this.el.sceneEl.camera.getWorldPosition(d);const e=d.distanceTo(f);1==this.portalType&&e<1?this.locationhref||(console.log("set window.location.href to "+this.other),this.locationhref=this.other,window.location.href=this.other):2==this.portalType&&e<1?this.system.teleportTo(this.other.object3D):3==this.portalType&&(e<1?this.locationhref||(console.log("set window.location.hash to "+this.other),this.locationhref=this.other,window.location.hash=this.other):this.locationhref=null)}},getOther:function(){return new Promise((e=>{0==this.portalType&&e(null),1==this.portalType&&this.system.getRoomURL(this.portalTarget).then((t=>{e(t)})),3==this.portalType&&e("#"+this.portalTarget);const t=Array.from(document.querySelectorAll("[portal]")).find((e=>e.components.portal.portalType==this.portalType&&e.components.portal.portalTarget===this.portalTarget&&e!==this.el));void 0!==t?(e(t),t.emit("pair",{other:this.el})):this.el.addEventListener("pair",(t=>e(t.detail.other)),{once:!0})}))},parseNodeName:function(){const e=this.el.parentEl.parentEl.className,t=e.match(/([A-Za-z]*)_([A-Za-z0-9]*)_([A-Za-z0-9]*)$/);if(!t||t.length<4)return console.warn("portal node name not formed correctly: ",e),this.portalType=0,this.portalTarget=null,void(this.color="red");this.setPortalInfo(t[1],t[2],t[3])},setPortalInfo:function(e,t,i){"room"===e?(this.portalType=1,this.portalTarget=parseInt(t)):"portal"===e?(this.portalType=2,this.portalTarget=t):"waypoint"===e?(this.portalType=3,this.portalTarget=t):(this.portalType=0,this.portalTarget=null),this.color=new THREE.Color(i)},setRadius(e){this.el.setAttribute("animation__portal",{from:this.material.uniforms.radius.value,to:e})},open(){this.setRadius(1)},close(){this.setRadius(0)},isClosed(){return 0===this.material.uniforms.radius.value}});const g=new THREE.Vector3,x=new THREE.Vector3;AFRAME.registerComponent("immersive-360",{schema:{url:{type:"string",default:null}},init:async function(){const e=this.data.url??this.parseSpokeName(),t=e.match(/^.*\.(.*)$/)[1];this.el.setAttribute("media-image",{projection:"360-equirectangular",alphaMode:"opaque",src:e,version:1,batch:!1,contentType:`image/${t}`,alphaCutoff:0}),this.mesh=await this.getMesh(),this.mesh.geometry.scale(100,100,100),this.mesh.material.setValues({transparent:!0,depthTest:!1}),this.near=1,this.far=1.3,this.mesh.renderOrder=APP.RENDER_ORDER.CURSOR-1},tick:function(){if(this.mesh){this.mesh.getWorldPosition(x),this.el.sceneEl.camera.getWorldPosition(g);const e=1-(x.distanceTo(g)-this.near)/(this.far-this.near);this.mesh.material.opacity=e}},parseSpokeName:function(){const e=this.el.parentEl.parentEl.className,[,t,i]=e.match(/(?:.*__)?(.*)_(.*)/);return`https://gt-ael-aq-assets.aelatgt-internal.net/files/${t}.${i}`},getMesh:async function(){return new Promise((e=>{const t=this.el.object3DMap.mesh;t&&e(t),this.el.addEventListener("image-loaded",(()=>{e(this.el.object3DMap.mesh)}),{once:!0})}))}});const y=String.raw,b={modes:{none:"NO_PARALLAX",basic:"USE_BASIC_PARALLAX",steep:"USE_STEEP_PARALLAX",occlusion:"USE_OCLUSION_PARALLAX",relief:"USE_RELIEF_PARALLAX"},uniforms:{bumpMap:{value:null},map:{value:null},parallaxScale:{value:null},parallaxMinLayers:{value:null},parallaxMaxLayers:{value:null}},vertexShader:y`
    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    void main() {
      vUv = uv;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      vViewPosition = -mvPosition.xyz;
      vNormal = normalize( normalMatrix * normal );
      
      gl_Position = projectionMatrix * mvPosition;
    }
  `,fragmentShader:y`
    uniform sampler2D bumpMap;
    uniform sampler2D map;

    uniform float parallaxScale;
    uniform float parallaxMinLayers;
    uniform float parallaxMaxLayers;
    uniform float fade; // CUSTOM

    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    #ifdef USE_BASIC_PARALLAX

    vec2 parallaxMap(in vec3 V) {
      float initialHeight = texture2D(bumpMap, vUv).r;

      // No Offset Limitting: messy, floating output at grazing angles.
      //"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

      // Offset Limiting
      vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;
      return vUv - texCoordOffset;
    }

    #else

    vec2 parallaxMap(in vec3 V) {
      // Determine number of layers from angle between V and N
      float numLayers = mix(parallaxMaxLayers, parallaxMinLayers, abs(dot(vec3(0.0, 0.0, 1.0), V)));

      float layerHeight = 1.0 / numLayers;
      float currentLayerHeight = 0.0;
      // Shift of texture coordinates for each iteration
      vec2 dtex = parallaxScale * V.xy / V.z / numLayers;

      vec2 currentTextureCoords = vUv;

      float heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;

      // while ( heightFromTexture > currentLayerHeight )
      // Infinite loops are not well supported. Do a "large" finite
      // loop, but not too large, as it slows down some compilers.
      for (int i = 0; i < 30; i += 1) {
        if (heightFromTexture <= currentLayerHeight) {
          break;
        }
        currentLayerHeight += layerHeight;
        // Shift texture coordinates along vector V
        currentTextureCoords -= dtex;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
      }

      #ifdef USE_STEEP_PARALLAX

      return currentTextureCoords;

      #elif defined(USE_RELIEF_PARALLAX)

      vec2 deltaTexCoord = dtex / 2.0;
      float deltaHeight = layerHeight / 2.0;

      // Return to the mid point of previous layer
      currentTextureCoords += deltaTexCoord;
      currentLayerHeight -= deltaHeight;

      // Binary search to increase precision of Steep Parallax Mapping
      const int numSearches = 5;
      for (int i = 0; i < numSearches; i += 1) {
        deltaTexCoord /= 2.0;
        deltaHeight /= 2.0;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
        // Shift along or against vector V
        if (heightFromTexture > currentLayerHeight) {
          // Below the surface

          currentTextureCoords -= deltaTexCoord;
          currentLayerHeight += deltaHeight;
        } else {
          // above the surface

          currentTextureCoords += deltaTexCoord;
          currentLayerHeight -= deltaHeight;
        }
      }
      return currentTextureCoords;

      #elif defined(USE_OCLUSION_PARALLAX)

      vec2 prevTCoords = currentTextureCoords + dtex;

      // Heights for linear interpolation
      float nextH = heightFromTexture - currentLayerHeight;
      float prevH = texture2D(bumpMap, prevTCoords).r - currentLayerHeight + layerHeight;

      // Proportions for linear interpolation
      float weight = nextH / (nextH - prevH);

      // Interpolation of texture coordinates
      return prevTCoords * weight + currentTextureCoords * (1.0 - weight);

      #else // NO_PARALLAX

      return vUv;

      #endif
    }
    #endif

    vec2 perturbUv(vec3 surfPosition, vec3 surfNormal, vec3 viewPosition) {
      vec2 texDx = dFdx(vUv);
      vec2 texDy = dFdy(vUv);

      vec3 vSigmaX = dFdx(surfPosition);
      vec3 vSigmaY = dFdy(surfPosition);
      vec3 vR1 = cross(vSigmaY, surfNormal);
      vec3 vR2 = cross(surfNormal, vSigmaX);
      float fDet = dot(vSigmaX, vR1);

      vec2 vProjVscr = (1.0 / fDet) * vec2(dot(vR1, viewPosition), dot(vR2, viewPosition));
      vec3 vProjVtex;
      vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;
      vProjVtex.z = dot(surfNormal, viewPosition);

      return parallaxMap(vProjVtex);
    }

    void main() {
      vec2 mapUv = perturbUv(-vViewPosition, normalize(vNormal), normalize(vViewPosition));
      
      // CUSTOM START
      vec4 texel = texture2D(map, mapUv);
      vec3 color = mix(texel.xyz, vec3(0), fade);
      gl_FragColor = vec4(color, 1.0);
      // CUSTOM END
    }

  `},w=new THREE.Vector3,E=new THREE.Vector3(0,0,1);AFRAME.registerComponent("parallax",{schema:{strength:{type:"number",default:.5},cutoffTransition:{type:"number",default:Math.PI/8},cutoffAngle:{type:"number",default:Math.PI/4}},init:function(){const e=this.el.object3DMap.mesh,{map:t,emissiveMap:i}=e.material;t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping,i.wrapS=i.wrapT=THREE.ClampToEdgeWrapping;const{vertexShader:a,fragmentShader:o}=b;this.material=new THREE.ShaderMaterial({vertexShader:a,fragmentShader:o,defines:{USE_OCLUSION_PARALLAX:!0},uniforms:{map:{value:t},bumpMap:{value:i},parallaxScale:{value:-1*this.data.strength},parallaxMinLayers:{value:20},parallaxMaxLayers:{value:30},fade:{value:0}}}),e.material=this.material},tick(){if(this.el.sceneEl.camera){this.el.sceneEl.camera.getWorldPosition(w),this.el.object3D.worldToLocal(w);const l=w.angleTo(E),c=(e=l,t=this.data.cutoffAngle-this.data.cutoffTransition,i=this.data.cutoffAngle+this.data.cutoffTransition,r=function(e,t,i,a,o){return a+(e-t)*(o-a)/(i-t)}(e,t,i,a=0,o=1),n=a,s=o,Math.max(n,Math.min(s,r)));this.material.uniforms.fade.value=c}var e,t,i,a,o,r,n,s}});let C={uniforms:"insertbefore:#include <common>\n",functions:"insertafter:#include <clipping_planes_pars_vertex>\n",preTransform:"insertafter:#include <begin_vertex>\n",postTransform:"insertafter:#include <project_vertex>\n",preNormal:"insertafter:#include <beginnormal_vertex>\n"},T={uniforms:"insertbefore:#include <common>\n",functions:"insertafter:#include <clipping_planes_pars_fragment>\n",preFragColor:"insertbefore:gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",postFragColor:"insertafter:gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",postMap:"insertafter:#include <map_fragment>\n",replaceMap:"replace:#include <map_fragment>\n"};const R=(e,t,i)=>{let a;for(let o in t)i[o]&&(a=/insert(before):(.*)|insert(after):(.*)|(replace):(.*)/.exec(t[o]),a&&(a[1]?e=e.replace(a[2],i[o]+"\n"+a[2]):a[3]?e=e.replace(a[4],a[4]+"\n"+i[o]):a[5]&&(e=e.replace(a[6],i[o]))));return e};function _(e){var t={};for(var i in e)for(var a in t[i]={},e[i]){var o=e[i][a];o&&(o.isColor||o.isMatrix3||o.isMatrix4||o.isVector2||o.isVector3||o.isVector4||o.isTexture)?t[i][a]=o.clone():Array.isArray(o)?t[i][a]=o.slice():t[i][a]=o}return t}let S,A={MeshStandardMaterial:"standard",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshDepthMaterial:"depth",standard:"standard",basic:"basic",lambert:"lambert",phong:"phong",depth:"depth"};const M=e=>{if(!S){let e={standard:THREE.MeshStandardMaterial,basic:THREE.MeshBasicMaterial,lambert:THREE.MeshLambertMaterial,phong:THREE.MeshPhongMaterial,depth:THREE.MeshDepthMaterial};S={};for(let t in e)S[t]={ShaderClass:e[t],ShaderLib:THREE.ShaderLib[t],Key:t,Count:0,ModifiedName:function(){return`ModifiedMesh${this.Key[0].toUpperCase()+this.Key.slice(1)}Material_${++this.Count}`},TypeCheck:`isMesh${t[0].toUpperCase()+t.slice(1)}Material`}}let t;if("function"==typeof e){for(let i in S)if(S[i].ShaderClass===e){t=S[i];break}}else if("string"==typeof e){t=S[A[e]||e]}if(!t)throw new Error("No Shader found to modify...");return t};let L=new class{_vertexHooks;_fragmentHooks;constructor(e,t){this._vertexHooks={},this._fragmentHooks={},e&&this.defineVertexHooks(e),t&&this.defineFragmentHooks(t)}modify(e,t){let i=M(e);return{vertexShader:R(i.ShaderLib.vertexShader,this._vertexHooks,t.vertexShader||{}),fragmentShader:R(i.ShaderLib.fragmentShader,this._fragmentHooks,t.fragmentShader||{}),uniforms:Object.assign({},i.ShaderLib.uniforms,t.uniforms||{})}}extend(e,t){let i=M(e),a=R(i.ShaderLib.vertexShader,this._vertexHooks,t.vertexShader||{}),o=R(i.ShaderLib.fragmentShader,this._fragmentHooks,t.fragmentShader||{}),r=Object.assign({},i.ShaderLib.uniforms,t.uniforms||{}),n=t.className||i.ModifiedName(),s=new Function("BaseClass","uniforms","vertexShader","fragmentShader","cloneUniforms",`\n\n            var cls = function ${n}( params ){\n\n                BaseClass.call( this, params );\n\n                this.uniforms = cloneUniforms( uniforms );\n\n                this.vertexShader = vertexShader;\n                this.fragmentShader = fragmentShader;\n                this.type = '${n}';\n\n                this.setValues( params );\n\n            }\n\n            cls.prototype = Object.create( BaseClass.prototype );\n            cls.prototype.constructor = cls;\n            cls.prototype.${i.TypeCheck} = true;\n\n            cls.prototype.copy = function( source ){\n\n                BaseClass.prototype.copy.call( this, source );\n\n                this.uniforms = Object.assign( {}, source.uniforms );\n                this.vertexShader = vertexShader;\n                this.fragmentShader = fragmentShader;\n                this.type = '${n}';\n\n                return this;\n\n            }\n\n            return cls;\n\n        `);return t.postModifyVertexShader&&(a=t.postModifyVertexShader(a)),t.postModifyFragmentShader&&(o=t.postModifyFragmentShader(o)),s(i.ShaderClass,r,a,o,_)}defineVertexHooks(e){for(let t in e)this._vertexHooks[t]=e[t]}defineFragmentHooks(e){for(let t in e)this._fragmentHooks[t]=e[t]}}(C,T);var N="\n        // above here, the texture lookup will be done, which we\n        // can disable by removing the map from the material\n        // but if we leave it, we can also choose the blend the texture\n        // with our shader created color, or use it in the shader or\n        // whatever\n        //\n        // vec4 texelColor = texture2D( map, vUv );\n        // texelColor = mapTexelToLinear( texelColor );\n        \n        vec2 uv = mod(vUv.xy, vec2(1.0,1.0)); //mod(vUv.xy * texRepeat.xy + texOffset.xy, vec2(1.0,1.0));\n\n        if (uv.x < 0.0) { uv.x = uv.x + 1.0;}\n        if (uv.y < 0.0) { uv.y = uv.y + 1.0;}\n        if (texFlipY > 0) { uv.y = 1.0 - uv.y;}\n        uv.x = clamp(uv.x, 0.0, 1.0);\n        uv.y = clamp(uv.y, 0.0, 1.0);\n        \n        vec4 shaderColor;\n        mainImage(shaderColor, uv.xy * iResolution.xy);\n        shaderColor = mapTexelToLinear( shaderColor );\n\n        diffuseColor *= shaderColor;\n",D={iTime:{value:0},iResolution:{value:new THREE.Vector3(512,512,1)},texRepeat:{value:new THREE.Vector2(1,1)},texOffset:{value:new THREE.Vector2(0,0)},texFlipY:{value:0}},H="\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec2 texRepeat;\nuniform vec2 texOffset;\nuniform int texFlipY; \n  ";const P=String.raw,z=Object.assign({},D,{iChannel0:{value:null}});var k;(new THREE.TextureLoader).load("https://resources.realitymedia.digital/core-components/a448e34b8136fae5.png",(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,k=e}));let F={uniforms:z,vertexShader:{},fragmentShader:{uniforms:H+P`
      uniform sampler2D iChannel0;
        `,functions:P`
      // By Daedelus: https://www.shadertoy.com/user/Daedelus
      // license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
      #define TIMESCALE 0.25 
      #define TILES 8
      #define COLOR 0.7, 1.6, 2.8

      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
        vec2 uv = fragCoord.xy / iResolution.xy;
        uv.x *= iResolution.x / iResolution.y;
        
        vec4 noise = texture2D(iChannel0, floor(uv * float(TILES)) / float(TILES));
        float p = 1.0 - mod(noise.r + noise.g + noise.b + iTime * float(TIMESCALE), 1.0);
        p = min(max(p * 3.0 - 1.8, 0.1), 2.0);
        
        vec2 r = mod(uv * float(TILES), 1.0);
        r = vec2(pow(r.x - 0.5, 2.0), pow(r.y - 0.5, 2.0));
        p *= 1.0 - pow(min(1.0, 12.0 * dot(r, r)), 2.0);
        
        fragColor = vec4(COLOR, 1.0) * p;
      }
      `,replaceMap:N},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=k},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e,t.uniforms.iChannel0.value=k}};const O=String.raw;let j={uniforms:Object.assign({},D),vertexShader:{},fragmentShader:{uniforms:H,functions:O`
        #define nPI 3.1415926535897932

        mat2 n_rotate2d(float angle){
                return mat2(cos(angle),-sin(angle),
                            sin(angle), cos(angle));
        }
        
        float n_stripe(float number) {
                float mod = mod(number, 2.0);
                //return step(0.5, mod)*step(1.5, mod);
                //return mod-1.0;
                return min(1.0, (smoothstep(0.0, 0.5, mod) - smoothstep(0.5, 1.0, mod))*1.0);
        }
        
        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 u_resolution = iResolution.xy;
                float u_time = iTime;
                vec3 color;
                vec2 st = fragCoord.xy;
                st += 2000.0 + 998000.0*step(1.75, 1.0-sin(u_time/8.0));
                st += u_time/2000.0;
                float m = (1.0+9.0*step(1.0, 1.0-sin(u_time/8.0)))/(1.0+9.0*step(1.0, 1.0-sin(u_time/16.0)));
                vec2 st1 = st * (400.0 + 1200.0*step(1.75, 1.0+sin(u_time)) - 300.0*step(1.5, 1.0+sin(u_time/3.0)));
                st = n_rotate2d(sin(st1.x)*sin(st1.y)/(m*100.0+u_time/100.0)) * st;
                vec2 st2 = st * (100.0 + 1900.0*step(1.75, 1.0-sin(u_time/2.0)));
                st = n_rotate2d(cos(st2.x)*cos(st2.y)/(m*100.0+u_time/100.0)) * st;
                st = n_rotate2d(0.5*nPI+(nPI*0.5*step( 1.0,1.0+ sin(u_time/1.0)))
                              +(nPI*0.1*step( 1.0,1.0+ cos(u_time/2.0)))+u_time*0.0001) * st;
                st *= 10.0;
                st /= u_resolution;
                color = vec3(n_stripe(st.x*u_resolution.x/10.0+u_time/10.0));
                fragColor = vec4(color, 1.0);
        }
            `,replaceMap:N},init:function(e){let t=e;e.uniforms.texFlipY={value:t.map.flipY?0:1}},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e}};const I=String.raw;let q={uniforms:Object.assign({},D),vertexShader:{},fragmentShader:{uniforms:H,functions:I`
      //// COLORS ////

      const vec3 ORANGE = vec3(1.0, 0.6, 0.2);
      const vec3 PINK   = vec3(0.7, 0.1, 0.4); 
      const vec3 BLUE   = vec3(0.0, 0.2, 0.9); 
      const vec3 BLACK  = vec3(0.0, 0.0, 0.2);
      
      ///// NOISE /////
      
      float hash( float n ) {
          //return fract(sin(n)*43758.5453123);   
          return fract(sin(n)*75728.5453123); 
      }
      
      
      float noise( in vec2 x ) {
          vec2 p = floor(x);
          vec2 f = fract(x);
          f = f*f*(3.0-2.0*f);
          float n = p.x + p.y*57.0;
          return mix(mix( hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);
      }
      
      ////// FBM ////// 
      
      mat2 m = mat2( 0.6, 0.6, -0.6, 0.8);
      float fbm(vec2 p){
       
          float f = 0.0;
          f += 0.5000 * noise(p); p *= m * 2.02;
          f += 0.2500 * noise(p); p *= m * 2.03;
          f += 0.1250 * noise(p); p *= m * 2.01;
          f += 0.0625 * noise(p); p *= m * 2.04;
          f /= 0.9375;
          return f;
      }
      
      
      void mainImage(out vec4 fragColor, in vec2 fragCoord){
          
          // pixel ratio
          
          vec2 uv = fragCoord.xy / iResolution.xy ;  
          vec2 p = - 1. + 2. * uv;
          p.x *= iResolution.x / iResolution.y;
           
          // domains
          
          float r = sqrt(dot(p,p)); 
          float a = cos(p.y * p.x);  
                 
          // distortion
          
          float f = fbm( 5.0 * p);
          a += fbm(vec2(1.9 - p.x, 0.9 * iTime + p.y));
          a += fbm(0.4 * p);
          r += fbm(2.9 * p);
             
          // colorize
          
          vec3 col = BLUE;
          
          float ff = 1.0 - smoothstep(-0.4, 1.1, noise(vec2(0.5 * a, 3.3 * a)) );        
          col =  mix( col, ORANGE, ff);
             
          ff = 1.0 - smoothstep(.0, 2.8, r );
          col +=  mix( col, BLACK,  ff);
          
          ff -= 1.0 - smoothstep(0.3, 0.5, fbm(vec2(1.0, 40.0 * a)) ); 
          col =  mix( col, PINK,  ff);  
            
          ff = 1.0 - smoothstep(2., 2.9, a * 1.5 ); 
          col =  mix( col, BLACK,  ff);  
                                                 
          fragColor = vec4(col, 1.);
      }
      `,replaceMap:N},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:new THREE.Vector2(t.map.offset.x+Math.random(),t.map.offset.x+Math.random())},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.userData.timeOffset=10*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset}};var U="https://resources.realitymedia.digital/core-components/cecefb50e408d105.png";const V=String.raw,B=Object.assign({},D,{iChannel0:{value:null}});var Y;(new THREE.TextureLoader).load(U,(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Y=e}));let W={uniforms:B,vertexShader:{},fragmentShader:{uniforms:H+V`
      uniform sampler2D iChannel0;
        `,functions:V`
        //CBS
        //Parallax scrolling fractal galaxy.
        //Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr
        
        // http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/
        float field(in vec3 p,float s) {
            float strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));
            float accum = s/4.;
            float prev = 0.;
            float tw = 0.;
            for (int i = 0; i < 26; ++i) {
                float mag = dot(p, p);
                p = abs(p) / mag + vec3(-.5, -.4, -1.5);
                float w = exp(-float(i) / 7.);
                accum += w * exp(-strength * pow(abs(mag - prev), 2.2));
                tw += w;
                prev = mag;
            }
            return max(0., 5. * accum / tw - .7);
        }
        
        // Less iterations for second layer
        float field2(in vec3 p, float s) {
            float strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));
            float accum = s/4.;
            float prev = 0.;
            float tw = 0.;
            for (int i = 0; i < 18; ++i) {
                float mag = dot(p, p);
                p = abs(p) / mag + vec3(-.5, -.4, -1.5);
                float w = exp(-float(i) / 7.);
                accum += w * exp(-strength * pow(abs(mag - prev), 2.2));
                tw += w;
                prev = mag;
            }
            return max(0., 5. * accum / tw - .7);
        }
        
        vec3 nrand3( vec2 co )
        {
            vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );
            vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );
            vec3 c = mix(a, b, 0.5);
            return c;
        }
        
        
        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
            vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;
            vec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);
            vec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);
            p += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));
            
            float freqs[4];
            //Sound
            freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;
            freqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;
            freqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;
            freqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;
        
            float t = field(p,freqs[2]);
            float v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));
            
            //Second Layer
            vec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);
            p2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));
            float t2 = field2(p2,freqs[3]);
            vec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);
            
            
            //Let's add some stars
            //Thanks to http://glsl.heroku.com/e#6904.0
            vec2 seed = p.xy * 2.0;	
            seed = floor(seed * iResolution.x);
            vec3 rnd = nrand3( seed );
            vec4 starcolor = vec4(pow(rnd.y,40.0));
            
            //Second Layer
            vec2 seed2 = p2.xy * 2.0;
            seed2 = floor(seed2 * iResolution.x);
            vec3 rnd2 = nrand3( seed2 );
            starcolor += vec4(pow(rnd2.y,40.0));
            
            fragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;
        }
       `,replaceMap:N},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=Y,e.userData.timeOffset=1e5*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=Y}};const X=String.raw,G=Object.assign({},D,{iChannel0:{value:null}});var $;(new THREE.TextureLoader).load(U,(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,$=e}));let Z={uniforms:G,vertexShader:{},fragmentShader:{uniforms:H+X`
      uniform sampler2D iChannel0;
        `,functions:X`
        // Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)
        // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
        // Tuned via XShade (http://www.funparadigm.com/xshade/)
        
        vec2 lt_mo = vec2(0);
        
        float lt_pn( in vec3 x ) // iq noise
        {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f*f*(3.0-2.0*f);
            vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
            vec2 rg = texture(iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;
            return -1.0+2.4*mix( rg.x, rg.y, f.z );
        }
        
        vec2 lt_path(float t)
        {
            return vec2(cos(t*0.2), sin(t*0.2)) * 2.;
        }
        
        const mat3 lt_mx = mat3(1,0,0,0,7,0,0,0,7);
        const mat3 lt_my = mat3(7,0,0,0,1,0,0,0,7);
        const mat3 lt_mz = mat3(7,0,0,0,7,0,0,0,1);
        
        // base on shane tech in shader : One Tweet Cellular Pattern
        float lt_func(vec3 p)
        {
            p = fract(p/68.6) - .5;
            return min(min(abs(p.x), abs(p.y)), abs(p.z)) + 0.1;
        }
        
        vec3 lt_effect(vec3 p)
        {
            p *= lt_mz * lt_mx * lt_my * sin(p.zxy); // sin(p.zxy) is based on iq tech from shader (Sculpture III)
            return vec3(min(min(lt_func(p*lt_mx), lt_func(p*lt_my)), lt_func(p*lt_mz))/.6);
        }
        //
        
        vec4 lt_displacement(vec3 p)
        {
            vec3 col = 1.-lt_effect(p*0.8);
               col = clamp(col, -.5, 1.);
            float dist = dot(col,vec3(0.023));
            col = step(col, vec3(0.82));// black line on shape
            return vec4(dist,col);
        }
        
        vec4 lt_map(vec3 p)
        {
            p.xy -= lt_path(p.z);
            vec4 disp = lt_displacement(sin(p.zxy*2.)*0.8);
            p += sin(p.zxy*.5)*1.5;
            float l = length(p.xy) - 4.;
            return vec4(max(-l + 0.09, l) - disp.x, disp.yzw);
        }
        
        vec3 lt_nor( in vec3 pos, float prec )
        {
            vec3 eps = vec3( prec, 0., 0. );
            vec3 lt_nor = vec3(
                lt_map(pos+eps.xyy).x - lt_map(pos-eps.xyy).x,
                lt_map(pos+eps.yxy).x - lt_map(pos-eps.yxy).x,
                lt_map(pos+eps.yyx).x - lt_map(pos-eps.yyx).x );
            return normalize(lt_nor);
        }
        
        
        vec4 lt_light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)
        {
            vec3 p = ro + rd * d;
            
            // original normale
            vec3 n = lt_nor(p, 0.1);
            
            vec3 lightdir = lightpos - p;
            float lightlen = length(lightpos - p);
            lightdir /= lightlen;
            
            float amb = 0.6;
            float diff = clamp( dot( n, lightdir ), 0.0, 1.0 );
                
            vec3 brdf = vec3(0);
            brdf += amb * vec3(0.2,0.5,0.3); // color mat
            brdf += diff * 0.6;
            
            brdf = mix(brdf, lt_map(p).yzw, 0.5);// merge light and black line pattern
                
            return vec4(brdf, lightlen);
        }
        
        vec3 lt_stars(vec2 uv, vec3 rd, float d, vec2 s, vec2 g)
        {
            uv *= 800. * s.x/s.y;
            float k = fract( cos(uv.y * 0.0001 + uv.x) * 90000.);
            float var = sin(lt_pn(d*0.6+rd*182.14))*0.5+0.5;// thank to klems for the variation in my shader subluminic
            vec3 col = vec3(mix(0., 1., var*pow(k, 200.)));// come from CBS Shader "Simplicity" : https://www.shadertoy.com/view/MslGWN
            return col;
        }
        
        ////////MAIN///////////////////////////////
        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            vec2 s = iResolution.xy;
            vec2 g = fragCoord;
            
           
            float time = iTime*1.0;
            float cam_a = time; // angle z
            
            float cam_e = 3.2; // elevation
            float cam_d = 4.; // distance to origin axis
            
            float maxd = 40.; // ray marching distance max
            
            vec2 uv = (g*2.-s)/s.y;
            
            vec3 col = vec3(0.);
        
            vec3 ro = vec3(lt_path(time)+lt_mo,time);
              vec3 cv = vec3(lt_path(time+0.1)+lt_mo,time+0.1);
            
            vec3 cu=vec3(0,1,0);
              vec3 rov = normalize(cv-ro);
            vec3 u = normalize(cross(cu,rov));
              vec3 v = cross(rov,u);
              vec3 rd = normalize(rov + uv.x*u + uv.y*v);
            
            vec3 curve0 = vec3(0);
            vec3 curve1 = vec3(0);
            vec3 curve2 = vec3(0);
            float outStep = 0.;
            
            float ao = 0.; // ao low cost :)
            
            float st = 0.;
            float d = 0.;
            for(int i=0;i<250;i++)
            {      
                if (st<0.025*log(d*d/st/1e5)||d>maxd) break;// special break condition for low thickness object
                st = lt_map(ro+rd*d).x;
                d += st * 0.6; // the 0.6 is selected according to the 1e5 and the 0.025 of the break condition for good result
                ao++;
            }

            if (d < maxd)
            {
                vec4 li = lt_light(ro, rd, d, ro, vec3(0));// point light on the cam
                col = li.xyz/(li.w*0.2);// cheap light attenuation
                
                   col = mix(vec3(1.-ao/100.), col, 0.5);// low cost ao :)
                fragColor.rgb = mix( col, vec3(0), 1.0-exp( -0.003*d*d ) );
            }
            else
            {
                  fragColor.rgb = lt_stars(uv, rd, d, s, fragCoord);// stars bg
            }

            // vignette
            vec2 q = fragCoord/s;
            fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 ); // iq vignette
                
        }
       `,replaceMap:N},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=$,e.userData.timeOffset=10*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=$}};const K=String.raw,J=Object.assign({},D,{iChannel0:{value:null},iChannelResolution:{value:[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)]}});var Q;(new THREE.TextureLoader).load("https://resources.realitymedia.digital/core-components/f27e0104605f0cd7.png",(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Q=e,console.log("noise texture size: ",e.image.width,e.image.height)}));let ee={uniforms:J,vertexShader:{},fragmentShader:{uniforms:H+K`
      uniform sampler2D iChannel0;
      uniform vec3 iChannelResolution[4];
        `,functions:K`
        // Created by inigo quilez - iq/2013
// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. 
// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.
// You can share a link to it or an unmodified screenshot of it provided you attribute "by Inigo Quilez, @iquilezles and iquilezles.org". 
// If you are a techer, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.

float fire_noise( in vec3 x )
{
    vec3 p = floor(x);
    vec3 f = fract(x);
	f = f*f*(3.0-2.0*f);
	
	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
	vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;
	return mix( rg.x, rg.y, f.z );
}

vec4 fire_map( vec3 p )
{
	float den = 0.2 - p.y;

    // invert space	
	p = -7.0*p/dot(p,p);

    // twist space	
	float co = cos(den - 0.25*iTime);
	float si = sin(den - 0.25*iTime);
	p.xz = mat2(co,-si,si,co)*p.xz;

    // smoke	
	float f;
	vec3 q = p                          - vec3(0.0,1.0,0.0)*iTime;;
    f  = 0.50000*fire_noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.25000*fire_noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.12500*fire_noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.06250*fire_noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.03125*fire_noise( q );

	den = clamp( den + 4.0*f, 0.0, 1.0 );
	
	vec3 col = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), den ) + 0.05*sin(p);
	
	return vec4( col, den );
}

vec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel )
{
	vec4 sum = vec4( 0.0 );

	float t = 0.0;

    // dithering	
	t += 0.05*textureLod( iChannel0, pixel.xy/iChannelResolution[0].x, 0.0 ).x;
	
	for( int i=0; i<100; i++ )
	{
		if( sum.a > 0.99 ) break;
		
		vec3 pos = ro + t*rd;
		vec4 col = fire_map( pos );
		
		col.xyz *= mix( 3.1*vec3(1.0,0.5,0.05), vec3(0.48,0.53,0.5), clamp( (pos.y-0.2)/2.0, 0.0, 1.0 ) );
		
		col.a *= 0.6;
		col.rgb *= col.a;

		sum = sum + col*(1.0 - sum.a);	

		t += 0.05;
	}

	return clamp( sum.xyz, 0.0, 1.0 );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 q = fragCoord.xy / iResolution.xy;
    vec2 p = -1.0 + 2.0*q;
    p.x *= iResolution.x/ iResolution.y;
	
    vec2 mo = vec2(0.5,0.5); //iMouse.xy / iResolution.xy;
    //if( iMouse.w<=0.00001 ) mo=vec2(0.0);
	
    // camera
    vec3 ro = 4.0*normalize(vec3(cos(3.0*mo.x), 1.4 - 1.0*(mo.y-.1), sin(3.0*mo.x)));
	vec3 ta = vec3(0.0, 1.0, 0.0);
	float cr = 0.5*cos(0.7*iTime);
	
    // shake		
	ro += 0.1*(-1.0+2.0*textureLod( iChannel0, iTime*vec2(0.010,0.014), 0.0 ).xyz);
	ta += 0.1*(-1.0+2.0*textureLod( iChannel0, iTime*vec2(0.013,0.008), 0.0 ).xyz);
	
	// build ray
    vec3 ww = normalize( ta - ro);
    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));
    vec3 vv = normalize(cross(ww,uu));
    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );
	
    // raymarch	
	vec3 col = raymarch( ro, rd, fragCoord );
	
	// contrast and vignetting	
	col = col*0.5 + 0.5*col*col*(3.0-2.0*col);
	col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );
	
    fragColor = vec4( col, 1.0 );
}

       `,replaceMap:N},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=Q,e.userData.timeOffset=1e5*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=Q,t.uniforms.iChannelResolution.value[0].x=Q.image.width,t.uniforms.iChannelResolution.value[0].y=Q.image.height}};const te=String.raw;let ie={uniforms:Object.assign({},D),vertexShader:{},fragmentShader:{uniforms:H,functions:te`

        float mrand(vec2 coords)
        {
            return fract(sin(dot(coords, vec2(56.3456,78.3456)) * 5.0) * 10000.0);
        }
        
        float mnoise(vec2 coords)
        {
            vec2 i = floor(coords);
            vec2 f = fract(coords);
        
            float a = mrand(i);
            float b = mrand(i + vec2(1.0, 0.0));
            float c = mrand(i + vec2(0.0, 1.0));
            float d = mrand(i + vec2(1.0, 1.0));
        
            vec2 cubic = f * f * (3.0 - 2.0 * f);
        
            return mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y;
        }
        
        float fbm(vec2 coords)
        {
            float value = 0.0;
            float scale = 0.5;
        
            for (int i = 0; i < 10; i++)
            {
                value += mnoise(coords) * scale;
                coords *= 4.0;
                scale *= 0.5;
            }
        
            return value;
        }
        
        
        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            vec2 uv = fragCoord.xy / iResolution.y * 2.0;
         
            float final = 0.0;
            
            for (int i =1; i < 6; i++)
            {
                vec2 motion = vec2(fbm(uv + vec2(0.0,iTime) * 0.05 + vec2(i, 0.0)));
        
                final += fbm(uv + motion);
        
            }
            
            final /= 5.0;
            fragColor = vec4(mix(vec3(-0.3), vec3(0.45, 0.4, 0.6) + vec3(0.6), final), 1);
        }
    `,replaceMap:N},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.userData.timeOffset=10*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.0012*e+t.userData.timeOffset}};const ae=String.raw,oe={animate:!1,noiseMode:"scale",invert:!1,sharpen:!0,scaleByPrev:!1,gain:.54,lacunarity:2,octaves:5,scale1:3,scale2:3,timeScaleX:.4,timeScaleY:.3,color1:[0,0,0],color2:[130,129,129],color3:[110,110,110],color4:[82,51,13],offsetAX:0,offsetAY:0,offsetBX:3.7,offsetBY:.9,offsetCX:2.1,offsetCY:3.2,offsetDX:4.3,offsetDY:2.8,offsetX:0,offsetY:0};let re={uniforms:{mb_animate:{value:oe.animate},mb_color1:{value:oe.color1.map((e=>e/255))},mb_color2:{value:oe.color2.map((e=>e/255))},mb_color3:{value:oe.color3.map((e=>e/255))},mb_color4:{value:oe.color4.map((e=>e/255))},mb_gain:{value:oe.gain},mb_invert:{value:oe.invert},mb_lacunarity:{value:oe.lacunarity},mb_noiseMode:{value:0},mb_octaves:{value:oe.octaves},mb_offset:{value:[oe.offsetX,oe.offsetY]},mb_offsetA:{value:[oe.offsetAX,oe.offsetAY]},mb_offsetB:{value:[oe.offsetBX,oe.offsetBY]},mb_offsetC:{value:[oe.offsetCX,oe.offsetCY]},mb_offsetD:{value:[oe.offsetDX,oe.offsetDY]},mb_scale1:{value:oe.scale1},mb_scale2:{value:oe.scale2},mb_scaleByPrev:{value:oe.scaleByPrev},mb_sharpen:{value:oe.sharpen},mb_time:{value:0},mb_timeScale:{value:[oe.timeScaleX,oe.timeScaleY]},texRepeat:{value:new THREE.Vector2(1,1)},texOffset:{value:new THREE.Vector2(0,0)}},vertexShader:{},fragmentShader:{uniforms:ae`
            uniform bool mb_animate;
            uniform vec3 mb_color1;
            uniform vec3 mb_color2;
            uniform vec3 mb_color3;
            uniform vec3 mb_color4;
            uniform float mb_gain;
            uniform bool mb_invert;
            uniform float mb_lacunarity;
            uniform int mb_noiseMode;
            uniform int mb_octaves;
            uniform vec2 mb_offset;
            uniform vec2 mb_offsetA;
            uniform vec2 mb_offsetB;
            uniform vec2 mb_offsetC;
            uniform vec2 mb_offsetD;
            uniform float mb_scale1;
            uniform float mb_scale2;
            uniform bool mb_scaleByPrev;
            uniform bool mb_sharpen;
            uniform float mb_time;
            uniform vec2 mb_timeScale;
            uniform vec2 texRepeat;
            uniform vec2 texOffset;
                    `,functions:ae`
        // Some useful functions
        vec3 mb_mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mb_mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 mb_permute(vec3 x) { return mb_mod289(((x*34.0)+1.0)*x); }
        
        //
        // Description : GLSL 2D simplex noise function
        //      Author : Ian McEwan, Ashima Arts
        //  Maintainer : ijm
        //     Lastmod : 20110822 (ijm)
        //     License :
        //  Copyright (C) 2011 Ashima Arts. All rights reserved.
        //  Distributed under the MIT License. See LICENSE file.
        //  https://github.com/ashima/webgl-noise
        //
        float mb_snoise(vec2 v) {
            // Precompute values for skewed triangular grid
            const vec4 C = vec4(0.211324865405187,
                                // (3.0-sqrt(3.0))/6.0
                                0.366025403784439,
                                // 0.5*(sqrt(3.0)-1.0)
                                -0.577350269189626,
                                // -1.0 + 2.0 * C.x
                                0.024390243902439);
                                // 1.0 / 41.0
        
            // First corner (x0)
            vec2 i  = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
        
            // Other two corners (x1, x2)
            vec2 i1 = vec2(0.0);
            i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);
            vec2 x1 = x0.xy + C.xx - i1;
            vec2 x2 = x0.xy + C.zz;
        
            // Do some permutations to avoid
            // truncation effects in permutation
            i = mb_mod289(i);
            vec3 p = mb_permute(
                    mb_permute( i.y + vec3(0.0, i1.y, 1.0))
                        + i.x + vec3(0.0, i1.x, 1.0 ));
        
            vec3 m = max(0.5 - vec3(
                                dot(x0,x0),
                                dot(x1,x1),
                                dot(x2,x2)
                                ), 0.0);
        
            m = m*m;
            m = m*m;
        
            // Gradients:
            //  41 pts uniformly over a line, mapped onto a diamond
            //  The ring size 17*17 = 289 is close to a multiple
            //      of 41 (41*7 = 287)
        
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
        
            // Normalise gradients implicitly by scaling m
            // Approximation of: m *= inversesqrt(a0*a0 + h*h);
            m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);
        
            // Compute final noise value at P
            vec3 g = vec3(0.0);
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);
            return 130.0 * dot(m, g);
        }
        
        float mb_getNoiseVal(vec2 p) {
            float raw = mb_snoise(p);
        
            if (mb_noiseMode == 1) {
                return abs(raw);
            }
        
            return raw * 0.5 + 0.5;
        }
        
        float mb_fbm(vec2 p) {
            float sum = 0.0;
            float freq = 1.0;
            float amp = 0.5;
            float prev = 1.0;
        
            for (int i = 0; i < mb_octaves; i++) {
                float n = mb_getNoiseVal(p * freq);
        
                if (mb_invert) {
                    n = 1.0 - n;
                }
        
                if (mb_sharpen) {
                    n = n * n;
                }
        
                sum += n * amp;
        
                if (mb_scaleByPrev) {
                    sum += n * amp * prev;
                }
        
                prev = n;
                freq *= mb_lacunarity;
                amp *= mb_gain;
            }
        
            return sum;
        }
        
        float mb_pattern(in vec2 p, out vec2 q, out vec2 r) {
            p *= mb_scale1;
            p += mb_offset;
        
            float t = 0.0;
            if (mb_animate) {
                t = mb_time * 0.1;
            }
        
            q = vec2(mb_fbm(p + mb_offsetA + t * mb_timeScale.x), mb_fbm(p + mb_offsetB - t * mb_timeScale.y));
            r = vec2(mb_fbm(p + mb_scale2 * q + mb_offsetC), mb_fbm(p + mb_scale2 * q + mb_offsetD));
        
            return mb_fbm(p + mb_scale2 * r);
        }
    `,replaceMap:ae`
        vec3 marbleColor = vec3(0.0);

        vec2 q;
        vec2 r;

        vec2 uv = mod(vUv.xy, vec2(1.0,1.0)); 
        if (uv.x < 0.0) { uv.x = uv.x + 1.0;}
        if (uv.y < 0.0) { uv.y = uv.y + 1.0;}
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);

        float f = mb_pattern(uv, q, r);
        
        marbleColor = mix(mb_color1, mb_color2, f);
        marbleColor = mix(marbleColor, mb_color3, length(q) / 2.0);
        marbleColor = mix(marbleColor, mb_color4, r.y / 2.0);

        vec4 marbleColor4 = mapTexelToLinear( vec4(marbleColor,1.0) );

        diffuseColor *= marbleColor4;
    `},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.mb_invert={value:t.map.flipY?oe.invert:!oe.invert},e.uniforms.mb_offsetA={value:new THREE.Vector2(oe.offsetAX+Math.random(),oe.offsetAY+Math.random())},e.uniforms.mb_offsetB={value:new THREE.Vector2(oe.offsetBX+Math.random(),oe.offsetBY+Math.random())}},updateUniforms:function(e,t){t.uniforms.mb_time.value=.001*e}};const ne=String.raw,se=Object.assign({},D,{iChannel0:{value:null},iChannel1:{value:null}}),le=new THREE.TextureLoader;var ce,me;le.load(U,(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,ce=e})),le.load("https://resources.realitymedia.digital/core-components/1ec965c5d6df577c.jpg",(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,me=e}));let he={uniforms:se,vertexShader:{},fragmentShader:{uniforms:H+ne`
        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        `,functions:ne`
        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            vec2 uv = fragCoord.xy / iResolution.xy;
            vec2 warpUV = 2. * uv;
        
            float d = length( warpUV );
            vec2 st = warpUV*0.1 + 0.2*vec2(cos(0.071*iTime*2.+d),
                                        sin(0.073*iTime*2.-d));
        
            vec3 warpedCol = texture( iChannel0, st ).xyz * 2.0;
            float w = max( warpedCol.r, 0.85);
            
            vec2 offset = 0.01 * cos( warpedCol.rg * 3.14159 );
            vec3 col = texture( iChannel1, uv + offset ).rgb * vec3(0.8, 0.8, 1.5) ;
            col *= w*1.2;
            
            fragColor = vec4( mix(col, texture( iChannel1, uv + offset ).rgb, 0.5),  1.0);
        }
        `,replaceMap:N},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=ce,e.uniforms.iChannel1.value=me,e.userData.timeOffset=1e4*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=ce,t.uniforms.iChannel1.value=me}};new THREE.Vector3,new THREE.Vector3(0,0,1),AFRAME.registerComponent("shader",{materials:[{}],shaderDef:{},schema:{name:{type:"string",default:"noise"},target:{type:"string",default:""}},init:function(){var e;switch(this.data.name){case"noise":e=j;break;case"liquidmarble":e=q;break;case"bleepyblocks":e=F;break;case"galaxy":e=W;break;case"lacetunnel":e=Z;break;case"firetunnel":e=ee;break;case"mist":e=ie;break;case"marble1":e=re;break;default:console.warn("unknown name '"+this.data.name+"' passed to shader component"),e=he}this.materials=[];let t=this.data.target;0==t.length&&(t=null);let i=a=>{let o=a;o.material&&function(e,t){let i=e;if(i.material)Array.isArray(i.material)?i.material.map(t):t(i.material)}(o,(i=>{if(!t||i.name===t){let t=(t=>{var i;try{i=L.extend(t.type,{uniforms:e.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})}catch(e){return}let a=new i;switch(t.type){case"MeshStandardMaterial":THREE.MeshStandardMaterial.prototype.copy.call(a,t);break;case"MeshPhongMaterial":THREE.MeshPhongMaterial.prototype.copy.call(a,t);break;case"MeshBasicMaterial":THREE.MeshBasicMaterial.prototype.copy.call(a,t)}return a.needsUpdate=!0,e.init(a),a})(i);t&&(o.material=t,this.materials.push(t))}}));const r=a.children;for(let e=0;e<r.length;e++)i(r[e])},a=()=>{var e=this.el.object3DMap.mesh;e||(e=this.el.object3D),i(e),this.el.removeEventListener("model-loaded",n)},o=r(this.el,"gltf-model-plus"),n=()=>{this.el.components["media-loader"]?this.el.addEventListener("media-loaded",a):a()};o.addEventListener("model-loaded",n),this.shaderDef=e},tick:function(e){null!=this.shaderDef&&this.materials.map((t=>{this.shaderDef.updateUniforms(e,t)}))}}),AFRAME.registerSystem("html-script",{init(){this.systemTick=e.systemTick,this.initializeEthereal=e.initializeEthereal,this.systemTick&&this.initializeEthereal?this.initializeEthereal():console.error("error in html-script system: htmlComponents has no systemTick and/or initializeEthereal methods")},tick(e,t){this.systemTick(e,t)}}),AFRAME.registerComponent("html-script",{schema:{name:{type:"string",default:""}},init:function(){this.script=null,this.fullName=this.data.name,this.fullName&&0!=this.fullName.length?this.componentName=this.fullName:this.parseNodeName(),r(this.el,"gltf-model-plus").addEventListener("model-loaded",(e=>{this.createScript()}))},update:function(){""!==this.data.name&&this.data.name!==this.fullName&&(this.fullName=this.data.name,this.componentName=this.fullName,this.script&&this.destroyScript(),this.createScript())},createScript:function(){let e=()=>{this.loadScript().then((()=>{if(!this.script)return;this.script.isNetworked&&(this.netEntity=null,this.getSharedData=this.getSharedData.bind(this),this.takeOwnership=this.takeOwnership.bind(this),this.setSharedData=this.setSharedData.bind(this),this.script.setNetworkMethods(this.takeOwnership,this.setSharedData));const e=document.createElement("a-entity");this.simpleContainer=e,this.simpleContainer.object3D.matrixAutoUpdate=!0,this.simpleContainer.setObject3D("weblayer3d",this.script.webLayer3D);var t=1,i=1;if(this.el.components["media-image"]){let e=this.el.object3DMap.mesh.scale,a=this.el.object3D.scale;t=e.x*a.x,i=e.y*a.y,a.x=1,a.y=1,a.z=1,this.el.object3D.matrixNeedsUpdate=!0}else{let e=this.el.object3DMap.mesh;if(e){let a=e.geometry.boundingBox;t=(a.max.x-a.min.x)*e.scale.x,i=(a.max.y-a.min.y)*e.scale.y}else{let e=this.el.object3D.scale;t=e.x,i=e.y,e.x=1,e.y=1,e.z=1,this.el.object3D.matrixNeedsUpdate=!0}var a=this.el.parentEl.parentEl.object3D;t*=a.scale.x,i*=a.scale.y,a.scale.x=1,a.scale.y=1,a.scale.z=1,a.matrixNeedsUpdate=!0}if(t>0&&i>0){const{width:e,height:a}=this.script.getSize();var o=Math.min(t/e,i/a);this.simpleContainer.setAttribute("scale",{x:o,y:o,z:o})}for(const e of this.el.object3D.children)e.visible=!1;this.script.isStatic&&(this.script.isInteractive||this.script.isNetworked)&&(this.script.isStatic=!1),this.el.appendChild(this.simpleContainer),this.script.isInteractive?(this.el.classList.contains("interactable"),this.simpleContainer.setAttribute("is-remote-hover-target",""),this.simpleContainer.setAttribute("tags",{singleActionButton:!0,inspectable:!0,isStatic:!0,togglesHoveredActionSet:!0}),this.simpleContainer.setAttribute("class","interactable"),this.clicked=this.clicked.bind(this),this.simpleContainer.object3D.addEventListener("interact",this.clicked),this.script.isDraggable&&(this.simpleContainer.setAttribute("tags",{singleActionButton:!0,isHoldable:!0,holdableButton:!0,inspectable:!0,isStatic:!0,togglesHoveredActionSet:!0}),this.simpleContainer.object3D.addEventListener("holdable-button-down",(e=>{this.script.dragStart(e)})),this.simpleContainer.object3D.addEventListener("holdable-button-up",(e=>{this.script.dragEnd(e)}))),this.hoverRayL=new THREE.Ray,this.hoverRayR=new THREE.Ray):this.el.classList.contains("interactable")&&this.el.classList.remove("interactable"),this.el.hasAttribute("networked")&&this.el.removeAttribute("networked"),this.script.isNetworked&&(this.setupNetworkedEntity=function(e){var t,i,a=!0;e?(t=NAF.utils.getNetworkId(e)+"-html-script",a=i.components.networked.data.persistent):t=this.fullName.replaceAll("_","-")+"-html-script",NAF.entities.hasEntity(t)?i=NAF.entities.getEntity(t):((i=document.createElement("a-entity")).getSharedData=this.getSharedData,i.setAttribute("networked",{template:"#script-data-media",persistent:a,owner:"scene",networkId:t}),this.el.sceneEl.appendChild(i)),this.netEntity=i,NAF.utils.getNetworkedEntity(this.netEntity).then((e=>{this.stateSync=e.components["script-data"],0===this.stateSync.sharedData&&e.components.networked}))},this.setupNetworkedEntity=this.setupNetworkedEntity.bind(this),this.setupNetworked=function(){NAF.utils.getNetworkedEntity(this.el).then((e=>{this.setupNetworkedEntity(e)})).catch((()=>{this.setupNetworkedEntity()}))},this.setupNetworked=this.setupNetworked.bind(this),NAF.connection&&NAF.connection.isConnected()?this.setupNetworked():this.el.sceneEl.addEventListener("didConnectToNetworkedScene",this.setupNetworked))}))};this.el.components["media-loader"]?this.el.addEventListener("media-loaded",(()=>{e()}),{once:!0}):e()},play:function(){this.script&&this.script.play()},pause:function(){this.script&&this.script.pause()},clicked:function(e){this.script.clicked(e)},takeOwnership:function(){return!this.stateSync||this.stateSync.takeOwnership()},setSharedData:function(e){return!this.stateSync||this.stateSync.setSharedData(e)},getSharedData:function(){return this.script?this.script.getSharedData():(console.warn("script-data component called parent element but there is no script yet?"),"{}")},tick:function(e){if(this.script){if(this.script.isInteractive){const e=this.el.sceneEl.systems["hubs-systems"].cursorTogglingSystem;var t=[];let i,a;const o=this.el.sceneEl.systems.interaction;if(!o.ready)return;let r=this.simpleContainer;if(o.state.leftHand.hovered!==r||o.state.leftHand.held||(i=o.options.leftHand.entity.object3D),o.state.leftRemote.hovered!==r||o.state.leftRemote.held||e.leftToggledOff||(i=o.options.leftRemote.entity.object3D),i){let e=i.position,a=this.script.webLayer3D.getWorldDirection(new THREE.Vector3).negate();e.addScaledVector(a,-.1),this.hoverRayL.set(e,a),t.push(this.hoverRayL)}if(o.state.rightRemote.hovered!==r||o.state.rightRemote.held||e.rightToggledOff||(a=o.options.rightRemote.entity.object3D),o.state.rightHand.hovered!==r||o.state.rightHand.held||(a=o.options.rightHand.entity.object3D),a){let e=a.position,i=this.script.webLayer3D.getWorldDirection(new THREE.Vector3).negate();e.addScaledVector(i,-.1),this.hoverRayR.set(e,i),t.push(this.hoverRayR)}this.script.webLayer3D.interactionRays=t}if(this.script.isNetworked){if(!this.netEntity||!this.stateSync)return;this.stateSync.changed&&(this.stateSync.changed=!1,this.script.updateSharedData(this.stateSync.dataObject))}this.script.tick(e)}},parseNodeName:function(){""===this.fullName&&(this.fullName=this.el.parentEl.parentEl.className);const e=this.fullName.match(/_([A-Za-z0-9]*)$/);!e||e.length<2?(console.warn("html-script componentName not formatted correctly: ",this.fullName),this.componentName=null):this.componentName=e[1]},loadScript:async function(){var t=e[this.componentName];if(!t)return console.warn("'html-script' component doesn't have script for "+this.componentName),void(this.script=null);this.script=t(),this.script?this.script.needsUpdate=!0:console.warn("'html-script' component failed to initialize script for "+this.componentName)},destroyScript:function(){this.script.isInteractive&&this.simpleContainer.object3D.removeEventListener("interact",this.clicked),this.el.removeChild(this.simpleContainer),this.simpleContainer=null,this.script.destroy(),this.script=null}}),AFRAME.registerComponent("script-data",{schema:{scriptdata:{type:"string",default:"{}"}},init:function(){this.takeOwnership=this.takeOwnership.bind(this),this.setSharedData=this.setSharedData.bind(this),this.dataObject=this.el.getSharedData();try{this.sharedData=encodeURIComponent(JSON.stringify(this.dataObject)),this.el.setAttribute("script-data","scriptdata",this.sharedData)}catch(e){console.error("Couldn't encode initial script data object: ",e,this.dataObject),this.sharedData="{}",this.dataObject={}}this.changed=!1},update(){if(this.changed=!(this.sharedData===this.data.scriptdata),this.changed)try{this.dataObject=JSON.parse(decodeURIComponent(this.data.scriptdata)),this.sharedData=this.data.scriptdata,this.changed=!0}catch(e){console.error("couldn't parse JSON received in script-sync: ",e),this.sharedData="",this.dataObject={}}},play(){this.el.components.networked&&APP.utils&&APP.utils.applyPersistentSync(this.el.components.networked.data.networkId)},takeOwnership(){return!(!NAF.utils.isMine(this.el)&&!NAF.utils.takeOwnership(this.el))},setSharedData(e){if(!NAF.utils.isMine(this.el)&&!NAF.utils.takeOwnership(this.el))return!1;try{var t=encodeURIComponent(JSON.stringify(e));return this.sharedData=t,this.dataObject=e,this.el.setAttribute("script-data","scriptdata",t),!0}catch(e){return console.error("can't stringify the object passed to script-sync"),!1}}});document.querySelector("a-assets").insertAdjacentHTML("beforeend",'\n    <template id="script-data-media">\n      <a-entity\n        script-data\n      ></a-entity>\n    </template>\n  '),NAF.schemas.add({template:"#script-data-media",components:[{component:"script-data",property:"scriptdata"}],nonAuthorizedComponents:[{component:"script-data",property:"scriptdata"}]}),AFRAME.GLTFModelPlus.registerComponent("immersive-360","immersive-360"),AFRAME.GLTFModelPlus.registerComponent("portal","portal"),AFRAME.GLTFModelPlus.registerComponent("shader","shader"),AFRAME.GLTFModelPlus.registerComponent("parallax","parallax"),AFRAME.GLTFModelPlus.registerComponent("html-script","html-script"),AFRAME.GLTFModelPlus.registerComponent("region-hider","region-hider");
